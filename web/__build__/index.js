/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/__build__/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./web/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pdf-annotate.js/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (_src_PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/index.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js":
/*!***********************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _adapter_StoreAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter/StoreAdapter */ \"./node_modules/pdf-annotate.js/src/adapter/StoreAdapter.js\");\n/* harmony import */ var _adapter_LocalStoreAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapter/LocalStoreAdapter */ \"./node_modules/pdf-annotate.js/src/adapter/LocalStoreAdapter.js\");\n/* harmony import */ var _adapter_LocalUserStoreAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapter/LocalUserStoreAdapter */ \"./node_modules/pdf-annotate.js/src/adapter/LocalUserStoreAdapter.js\");\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render */ \"./node_modules/pdf-annotate.js/src/render/index.js\");\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UI */ \"./node_modules/pdf-annotate.js/src/UI/index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ \"./node_modules/pdf-annotate.js/src/config.js\");\n/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/pdf-annotate.js/src/utils/uuid.js\");\n/* harmony import */ var _UI_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UI/utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  findAnnotationAtPoint: _UI_utils__WEBPACK_IMPORTED_MODULE_7__[\"findAnnotationAtPoint\"],\r\n  findSVGContainer: _UI_utils__WEBPACK_IMPORTED_MODULE_7__[\"findSVGContainer\"],\r\n  convertToScreenPoint: _UI_utils__WEBPACK_IMPORTED_MODULE_7__[\"convertToScreenPoint\"],\r\n\r\n  /**\r\n   * Abstract class that needs to be defined so PDFJSAnnotate\r\n   * knows how to communicate with your server.\r\n   */\r\n  StoreAdapter: _adapter_StoreAdapter__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\r\n\r\n  /**\r\n   * Implementation of StoreAdapter that stores annotation data to localStorage.\r\n   */\r\n  LocalStoreAdapter: _adapter_LocalStoreAdapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\r\n\r\n  /**\r\n   * Implementation of StoreAdapter that stores annotation data to localStorage particular\r\n   * to a specific user\r\n   */\r\n  LocalUserStoreAdapter: _adapter_LocalUserStoreAdapter__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\r\n\r\n  /**\r\n   * Abstract instance of StoreAdapter\r\n   */\r\n  __storeAdapter: new _adapter_StoreAdapter__WEBPACK_IMPORTED_MODULE_0__[\"default\"](),\r\n\r\n  /**\r\n   * Getter for the underlying StoreAdapter property\r\n   *\r\n   * @return {StoreAdapter}\r\n   */\r\n  getStoreAdapter() {\r\n    return this.__storeAdapter;\r\n  },\r\n\r\n  /**\r\n   * Setter for the underlying StoreAdapter property\r\n   *\r\n   * @param {StoreAdapter} adapter The StoreAdapter implementation to be used.\r\n   */\r\n  setStoreAdapter(adapter) {\r\n    // TODO this throws an error when bundled\r\n    // if (!(adapter instanceof StoreAdapter)) {\r\n    //   throw new Error('adapter must be an instance of StoreAdapter');\r\n    // }\r\n\r\n    this.__storeAdapter = adapter;\r\n  },\r\n\r\n  /**\r\n   * UI is a helper for instrumenting UI interactions for creating,\r\n   * editing, and deleting annotations in the browser.\r\n   */\r\n  UI: _UI__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\r\n\r\n  /**\r\n   * Render the annotations for a page in the PDF Document\r\n   *\r\n   * @param {SVGElement} svg The SVG element that annotations should be rendered to\r\n   * @param {PageViewport} viewport The PDFPage.getViewport data\r\n   * @param {Object} data The StoreAdapter.getAnnotations data\r\n   * @return {Promise}\r\n   */\r\n  render: _render__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\r\n\r\n  /**\r\n   * Convenience method for getting annotation data\r\n   *\r\n   * @alias StoreAdapter.getAnnotations\r\n   * @param {String} documentId The ID of the document\r\n   * @param {String} pageNumber The page number\r\n   * @return {Promise}\r\n   */\r\n  getAnnotations(documentId, pageNumber) {\r\n    return this.getStoreAdapter().getAnnotations(...arguments);\r\n  },\r\n\r\n  config: _config__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\r\n\r\n  uuid: _utils_uuid__WEBPACK_IMPORTED_MODULE_6__[\"default\"]\r\n});\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/arrow.js":
/*!******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/arrow.js ***!
  \******************************************************/
/*! exports provided: setArrow, enableArrow, disableArrow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setArrow\", function() { return setArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableArrow\", function() { return enableArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableArrow\", function() { return disableArrow; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet _penSize;\r\nlet _penColor;\r\nlet path;\r\nlet lines;\r\nlet originY;\r\nlet originX;\r\n\r\n/**\r\n * Handle document.mousedown event\r\n */\r\nfunction handleDocumentMousedown(e) {\r\n  let target = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findAnnotationAtPoint\"])(e.clientX, e.clientY);\r\n  if (target === null) {\r\n    return;\r\n  }\r\n\r\n  let type = target.getAttribute('data-pdf-annotate-type');\r\n  if (type !== 'circle' && type !== 'fillcircle' && type !== 'emptycircle') {\r\n    return;\r\n  }\r\n\r\n  let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGContainer\"])(target);\r\n  let { documentId } = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getMetadata\"])(svg);\r\n  let annotationId = target.getAttribute('data-pdf-annotate-id');\r\n\r\n  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().getAnnotation(documentId, annotationId).then((annotation) => {\r\n    if (annotation) {\r\n      path = null;\r\n      lines = [];\r\n\r\n      let point = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"convertToScreenPoint\"])([\r\n        annotation.cx,\r\n        annotation.cy\r\n      ], svg);\r\n\r\n      let rect = svg.getBoundingClientRect();\r\n\r\n      originX = point[0] + rect.left;\r\n      originY = point[1] + rect.top;\r\n\r\n      document.addEventListener('mousemove', handleDocumentMousemove);\r\n      document.addEventListener('mouseup', handleDocumentMouseup);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Handle document.mouseup event\r\n *\r\n * @param {Event} e The DOM event to be handled\r\n */\r\nfunction handleDocumentMouseup(e) {\r\n  let svg;\r\n  if (lines.length > 1 && (svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(e.clientX, e.clientY))) {\r\n    let { documentId, pageNumber } = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getMetadata\"])(svg);\r\n\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addAnnotation(documentId, pageNumber, {\r\n      type: 'arrow',\r\n      width: _penSize,\r\n      color: _penColor,\r\n      lines\r\n    }).then((annotation) => {\r\n      if (path) {\r\n        svg.removeChild(path);\r\n      }\r\n\r\n      Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, annotation);\r\n    });\r\n  }\r\n\r\n  document.removeEventListener('mousemove', handleDocumentMousemove);\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\n/**\r\n * Handle document.mousemove event\r\n *\r\n * @param {Event} e The DOM event to be handled\r\n */\r\nfunction handleDocumentMousemove(e) {\r\n  let x = lines.length === 0 ? originX : e.clientX;\r\n  let y = lines.length === 0 ? originY : e.clientY;\r\n\r\n  savePoint(x, y);\r\n}\r\n\r\n/**\r\n * Handle document.keyup event\r\n *\r\n * @param {Event} e The DOM event to be handled\r\n */\r\nfunction handleDocumentKeyup(e) {\r\n  // Cancel rect if Esc is pressed\r\n  if (e.keyCode === 27) {\r\n    lines = null;\r\n    path.parentNode.removeChild(path);\r\n    document.removeEventListener('mousemove', handleDocumentMousemove);\r\n    document.removeEventListener('mouseup', handleDocumentMouseup);\r\n  }\r\n}\r\n\r\n/**\r\n * Save a point to the line being drawn.\r\n *\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n */\r\nfunction savePoint(x, y) {\r\n  let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(x, y);\r\n  if (!svg) {\r\n    return;\r\n  }\r\n\r\n  let rect = svg.getBoundingClientRect();\r\n  let point = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"convertToSvgPoint\"])([\r\n    x - rect.left,\r\n    y - rect.top\r\n  ], svg);\r\n\r\n  if (lines.length < 2) {\r\n    lines.push(point);\r\n    return;\r\n  }\r\n  else {\r\n    lines[1] = point; // update end point\r\n  }\r\n\r\n  if (path) {\r\n    svg.removeChild(path);\r\n  }\r\n\r\n  path = Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, {\r\n    type: 'arrow',\r\n    color: _penColor,\r\n    width: _penSize,\r\n    lines\r\n  });\r\n}\r\n\r\n/**\r\n * Set the attributes of the pen.\r\n *\r\n * @param {Number} penSize The size of the lines drawn by the pen\r\n * @param {String} penColor The color of the lines drawn by the pen\r\n */\r\nfunction setArrow(penSize = 10, penColor = '0000FF') {\r\n  _penSize = parseInt(penSize, 10);\r\n  _penColor = penColor;\r\n}\r\n\r\n/**\r\n * Enable the pen behavior\r\n */\r\nfunction enableArrow() {\r\n  if (_enabled) { return; }\r\n\r\n  _enabled = true;\r\n  document.addEventListener('mousedown', handleDocumentMousedown);\r\n  document.addEventListener('keyup', handleDocumentKeyup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"disableUserSelect\"])();\r\n}\r\n\r\n/**\r\n * Disable the pen behavior\r\n */\r\nfunction disableArrow() {\r\n  if (!_enabled) { return; }\r\n\r\n  _enabled = false;\r\n  document.removeEventListener('mousedown', handleDocumentMousedown);\r\n  document.removeEventListener('keyup', handleDocumentKeyup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"enableUserSelect\"])();\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/arrow.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/circle.js":
/*!*******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/circle.js ***!
  \*******************************************************/
/*! exports provided: setCircle, enableCircle, disableCircle, addCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setCircle\", function() { return setCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableCircle\", function() { return enableCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableCircle\", function() { return disableCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addCircle\", function() { return addCircle; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet _type;\r\nlet _circleRadius = 10;\r\nlet _circleColor = '0000FF';\r\n\r\n/**\r\n * Set the attributes of the pen.\r\n *\r\n * @param {Number} circleRadius The radius of the circle\r\n * @param {String} circleColor The color of the circle\r\n */\r\nfunction setCircle(circleRadius = 10, circleColor = '0000FF') {\r\n  _circleRadius = parseInt(circleRadius, 10);\r\n  _circleColor = circleColor;\r\n}\r\n\r\n/**\r\n * Handle document.mouseup event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleDocumentMouseup(e) {\r\n  let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(e.clientX, e.clientY);\r\n  if (!svg) {\r\n    return;\r\n  }\r\n  let rect = svg.getBoundingClientRect();\r\n  saveCircle(svg, _type, {\r\n    x: e.clientX - rect.left,\r\n    y: e.clientY - rect.top\r\n  }, _circleRadius, _circleColor);\r\n}\r\n\r\n/**\r\n * Save a circle annotation\r\n *\r\n * @param {SVGElement} svg\r\n * @param {String} type The type of circle (circle, emptycircle, fillcircle)\r\n * @param {Object} pt The point to use for annotation\r\n * @param {float} radius\r\n * @param {String} color The color of the rects\r\n */\r\nfunction saveCircle(svg, type, pt, radius, color) {\r\n  // Initialize the annotation\r\n  let svg_pt = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"convertToSvgPoint\"])([ pt.x, pt.y ], svg);\r\n  let annotation = {\r\n    type,\r\n    color,\r\n    cx: svg_pt[0],\r\n    cy: svg_pt[1],\r\n    r: radius\r\n  };\r\n\r\n  let { documentId, pageNumber } = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getMetadata\"])(svg);\r\n\r\n  // Add the annotation\r\n  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)\r\n    .then((annotation) => {\r\n      Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, annotation);\r\n    });\r\n}\r\n\r\n/**\r\n * Enable circle behavior\r\n */\r\nfunction enableCircle(type) {\r\n  _type = type;\r\n\r\n  if (_enabled) { return; }\r\n\r\n  _enabled = true;\r\n  document.addEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\n/**\r\n * Disable circle behavior\r\n */\r\nfunction disableCircle() {\r\n  if (!_enabled) { return; }\r\n\r\n  _enabled = false;\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\nfunction addCircle(type, e) {\r\n  let oldType = _type;\r\n  _type = type;\r\n  handleDocumentMouseup(e);\r\n  _type = oldType;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/circle.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/edit.js":
/*!*****************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/edit.js ***!
  \*****************************************************/
/*! exports provided: enableEdit, disableEdit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableEdit\", function() { return enableEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableEdit\", function() { return disableEdit; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./node_modules/pdf-annotate.js/src/config.js\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ \"./node_modules/pdf-annotate.js/src/UI/event.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet isDragging = false;\r\nlet overlay;\r\nlet dragOffsetX, dragOffsetY, dragStartX, dragStartY;\r\nconst OVERLAY_BORDER_SIZE = 3;\r\n\r\n/**\r\n * Create an overlay for editing an annotation.\r\n *\r\n * @param {Element} target The annotation element to apply overlay for\r\n */\r\nfunction createEditOverlay(target) {\r\n  destroyEditOverlay();\r\n\r\n  overlay = document.createElement('div');\r\n  let anchor = document.createElement('a');\r\n  let parentNode = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"findSVGContainer\"])(target).parentNode;\r\n  let id = target.getAttribute('data-pdf-annotate-id');\r\n  let rect = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"getOffsetAnnotationRect\"])(target);\r\n  let styleLeft = rect.left - OVERLAY_BORDER_SIZE;\r\n  let styleTop = rect.top - OVERLAY_BORDER_SIZE;\r\n\r\n  overlay.setAttribute('id', 'pdf-annotate-edit-overlay');\r\n  overlay.setAttribute('data-target-id', id);\r\n  overlay.style.boxSizing = 'content-box';\r\n  overlay.style.position = 'absolute';\r\n  overlay.style.top = `${styleTop}px`;\r\n  overlay.style.left = `${styleLeft}px`;\r\n  overlay.style.width = `${rect.width}px`;\r\n  overlay.style.height = `${rect.height}px`;\r\n  overlay.style.border = `${OVERLAY_BORDER_SIZE}px solid ${_utils__WEBPACK_IMPORTED_MODULE_3__[\"BORDER_COLOR\"]}`;\r\n  overlay.style.borderRadius = `${OVERLAY_BORDER_SIZE}px`;\r\n  overlay.style.zIndex = 20100;\r\n\r\n  anchor.innerHTML = 'Ã—';\r\n  anchor.setAttribute('href', 'javascript://');\r\n  anchor.style.background = '#fff';\r\n  anchor.style.borderRadius = '20px';\r\n  anchor.style.border = '1px solid #bbb';\r\n  anchor.style.color = '#bbb';\r\n  anchor.style.fontSize = '16px';\r\n  anchor.style.padding = '2px';\r\n  anchor.style.textAlign = 'center';\r\n  anchor.style.textDecoration = 'none';\r\n  anchor.style.position = 'absolute';\r\n  anchor.style.top = '-13px';\r\n  anchor.style.right = '-13px';\r\n  anchor.style.width = '25px';\r\n  anchor.style.height = '25px';\r\n\r\n  overlay.appendChild(anchor);\r\n  parentNode.appendChild(overlay);\r\n  document.addEventListener('click', handleDocumentClick);\r\n  document.addEventListener('keyup', handleDocumentKeyup);\r\n  document.addEventListener('mousedown', handleDocumentMousedown);\r\n  anchor.addEventListener('click', deleteAnnotation);\r\n  anchor.addEventListener('mouseover', () => {\r\n    anchor.style.color = '#35A4DC';\r\n    anchor.style.borderColor = '#999';\r\n    anchor.style.boxShadow = '0 1px 1px #ccc';\r\n  });\r\n  anchor.addEventListener('mouseout', () => {\r\n    anchor.style.color = '#bbb';\r\n    anchor.style.borderColor = '#bbb';\r\n    anchor.style.boxShadow = '';\r\n  });\r\n  overlay.addEventListener('mouseover', () => {\r\n    if (!isDragging) { anchor.style.display = ''; }\r\n  });\r\n  overlay.addEventListener('mouseout', () => {\r\n    anchor.style.display = 'none';\r\n  });\r\n}\r\n\r\n/**\r\n * Destroy the edit overlay if it exists.\r\n */\r\nfunction destroyEditOverlay() {\r\n  if (overlay) {\r\n    overlay.parentNode.removeChild(overlay);\r\n    overlay = null;\r\n  }\r\n\r\n  document.removeEventListener('click', handleDocumentClick);\r\n  document.removeEventListener('keyup', handleDocumentKeyup);\r\n  document.removeEventListener('mousedown', handleDocumentMousedown);\r\n  document.removeEventListener('mousemove', handleDocumentMousemove);\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"enableUserSelect\"])();\r\n}\r\n\r\n/**\r\n * Delete currently selected annotation\r\n */\r\nfunction deleteAnnotation() {\r\n  if (!overlay) {\r\n    return;\r\n  }\r\n\r\n  let annotationId = overlay.getAttribute('data-target-id');\r\n  let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationSvgQuery());\r\n  let { documentId } = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"getMetadata\"])(svg);\r\n\r\n  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().deleteAnnotation(documentId, annotationId).then(() => {\r\n    let nodes = document.querySelectorAll(`[data-pdf-annotate-id=\"${annotationId}\"]`);\r\n\r\n    [...nodes].forEach((n) => {\r\n      n.parentNode.removeChild(n);\r\n    });\r\n  });\r\n\r\n  destroyEditOverlay();\r\n}\r\n\r\n/**\r\n * Handle document.click event\r\n *\r\n * @param {Event} e The DOM event that needs to be handled\r\n */\r\nfunction handleDocumentClick(e) {\r\n  if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"findSVGAtPoint\"])(e.clientX, e.clientY)) { return; }\r\n\r\n  // Remove current overlay\r\n  let overlay = document.getElementById('pdf-annotate-edit-overlay');\r\n  if (overlay) {\r\n    if (isDragging || e.target === overlay) {\r\n      return;\r\n    }\r\n\r\n    destroyEditOverlay();\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.keyup event\r\n *\r\n * @param {KeyboardEvent} e The DOM event that needs to be handled\r\n */\r\nfunction handleDocumentKeyup(e) {\r\n  // keyCode is deprecated, so prefer the newer \"key\" method if possible\r\n  let keyTest;\r\n  if (e.key) {\r\n    keyTest = e.key.toLowerCase() === 'delete' || e.key.toLowerCase() === 'backspace';\r\n  }\r\n  else {\r\n    keyTest = e.keyCode === 8 || e.keyCode === 46;\r\n  }\r\n  if (overlay && keyTest &&\r\n      e.target.nodeName.toLowerCase() !== 'textarea' &&\r\n      e.target.nodeName.toLowerCase() !== 'input') {\r\n    e.preventDefault();\r\n    deleteAnnotation();\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.mousedown event\r\n *\r\n * @param {Event} e The DOM event that needs to be handled\r\n */\r\nfunction handleDocumentMousedown(e) {\r\n  if (e.target !== overlay) {\r\n    return;\r\n  }\r\n\r\n  // Highlight and strikeout annotations are bound to text within the document.\r\n  // It doesn't make sense to allow repositioning these types of annotations.\r\n  let annotationId = overlay.getAttribute('data-target-id');\r\n  let target = document.querySelector(`[data-pdf-annotate-id=\"${annotationId}\"]`);\r\n  let type = target.getAttribute('data-pdf-annotate-type');\r\n\r\n  if (type === 'highlight' || type === 'strikeout') { return; }\r\n\r\n  isDragging = true;\r\n  dragOffsetX = e.clientX;\r\n  dragOffsetY = e.clientY;\r\n  dragStartX = overlay.offsetLeft;\r\n  dragStartY = overlay.offsetTop;\r\n\r\n  overlay.style.background = 'rgba(255, 255, 255, 0.7)';\r\n  overlay.style.cursor = 'move';\r\n  overlay.querySelector('a').style.display = 'none';\r\n\r\n  document.addEventListener('mousemove', handleDocumentMousemove);\r\n  document.addEventListener('mouseup', handleDocumentMouseup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"disableUserSelect\"])();\r\n}\r\n\r\n/**\r\n * Handle document.mousemove event\r\n *\r\n * @param {Event} e The DOM event that needs to be handled\r\n */\r\nfunction handleDocumentMousemove(e) {\r\n  let parentNode = overlay.parentNode;\r\n  let rect = parentNode.getBoundingClientRect();\r\n  let y = (dragStartY + (e.clientY - dragOffsetY));\r\n  let x = (dragStartX + (e.clientX - dragOffsetX));\r\n  let minY = 0;\r\n  let maxY = rect.height;\r\n  let minX = 0;\r\n  let maxX = rect.width;\r\n\r\n  if (y > minY && y + overlay.offsetHeight < maxY) {\r\n    overlay.style.top = `${y}px`;\r\n  }\r\n\r\n  if (x > minX && x + overlay.offsetWidth < maxX) {\r\n    overlay.style.left = `${x}px`;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.mouseup event\r\n *\r\n * @param {Event} e The DOM event that needs to be handled\r\n */\r\nfunction handleDocumentMouseup(e) {\r\n  let annotationId = overlay.getAttribute('data-target-id');\r\n  let target = document.querySelectorAll(`[data-pdf-annotate-id=\"${annotationId}\"]`);\r\n  let type = target[0].getAttribute('data-pdf-annotate-type');\r\n  let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationSvgQuery());\r\n  let { documentId } = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"getMetadata\"])(svg);\r\n\r\n  overlay.querySelector('a').style.display = '';\r\n\r\n  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().getAnnotation(documentId, annotationId).then((annotation) => {\r\n    let attribX = 'x';\r\n    let attribY = 'y';\r\n    if (['circle', 'fillcircle', 'emptycircle'].indexOf(type) > -1) {\r\n      attribX = 'cx';\r\n      attribY = 'cy';\r\n    }\r\n\r\n    if (type === 'point') {\r\n      // Broken\r\n      /*\r\n      [...target].forEach((t, i) => {\r\n        let moveTo = {\r\n          x: overlay.offsetLeft + 3,\r\n          y: overlay.offsetTop + 3\r\n        };\r\n        t.setAttribute(attribX, moveTo.x);\r\n        t.setAttribute(attribY, moveTo.y);\r\n        annotation[attribX] = moveTo.x;\r\n        annotation[attribY] = moveTo.y;\r\n      });\r\n      */\r\n      return;\r\n    }\r\n    else if (['area', 'highlight', 'textbox', 'circle', 'fillcircle', 'emptycircle'].indexOf(type) > -1) {\r\n      let modelStart = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"convertToSvgPoint\"])([dragStartX, dragStartY], svg);\r\n      let modelEnd = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"convertToSvgPoint\"])([overlay.offsetLeft, overlay.offsetTop], svg);\r\n      let modelDelta = {\r\n        x: modelEnd[0] - modelStart[0],\r\n        y: modelEnd[1] - modelStart[1]\r\n      };\r\n\r\n      if (type === 'textbox') {\r\n        target = [target[0].firstChild];\r\n      }\r\n\r\n      [...target].forEach((t, i) => {\r\n        let modelX = parseInt(t.getAttribute(attribX), 10);\r\n        let modelY = parseInt(t.getAttribute(attribY), 10);\r\n        if (modelDelta.y !== 0) {\r\n          modelY = modelY + modelDelta.y;\r\n\r\n          t.setAttribute(attribY, modelY);\r\n          if (annotation.rectangles && i < annotation.rectangles.length) {\r\n            annotation.rectangles[i].y = modelY;\r\n          }\r\n          else if (annotation[attribY]) {\r\n            annotation[attribY] = modelY;\r\n          }\r\n        }\r\n        if (modelDelta.x !== 0) {\r\n          modelX = modelX + modelDelta.x;\r\n\r\n          t.setAttribute(attribX, modelX);\r\n          if (annotation.rectangles && i < annotation.rectangles.length) {\r\n            annotation.rectangles[i].x = modelX;\r\n          }\r\n          else if (annotation[attribX]) {\r\n            annotation[attribX] = modelX;\r\n          }\r\n        }\r\n      });\r\n    }\r\n    else if (type === 'strikeout') {\r\n      return;\r\n    //   let { deltaX, deltaY } = getDelta('x1', 'y1');\r\n    //   [...target].forEach(target, (t, i) => {\r\n    //     if (deltaY !== 0) {\r\n    //       t.setAttribute('y1', parseInt(t.getAttribute('y1'), 10) + deltaY);\r\n    //       t.setAttribute('y2', parseInt(t.getAttribute('y2'), 10) + deltaY);\r\n    //       annotation.rectangles[i].y = parseInt(t.getAttribute('y1'), 10);\r\n    //     }\r\n    //     if (deltaX !== 0) {\r\n    //       t.setAttribute('x1', parseInt(t.getAttribute('x1'), 10) + deltaX);\r\n    //       t.setAttribute('x2', parseInt(t.getAttribute('x2'), 10) + deltaX);\r\n    //       annotation.rectangles[i].x = parseInt(t.getAttribute('x1'), 10);\r\n    //     }\r\n    //   });\r\n    }\r\n    else if (type === 'drawing' || type === 'arrow') {\r\n      // Do nothing as currently broken\r\n      /*\r\n      let modelStart = convertToSvgPoint([dragStartX, dragStartY], svg);\r\n      let modelEnd = convertToSvgPoint([overlay.offsetLeft, overlay.offsetTop], svg);\r\n      let modelDelta = {\r\n        x: modelEnd[0] - modelStart[0],\r\n        y: modelEnd[1] - modelStart[1]\r\n      };\r\n\r\n      annotation.lines.forEach((line, i) => {\r\n        let [x, y] = annotation.lines[i];\r\n        annotation.lines[i][0] = x + modelDelta.x;\r\n        annotation.lines[i][1] = y + modelDelta.y;\r\n      });\r\n\r\n      target[0].parentNode.removeChild(target[0]);\r\n      appendChild(svg, annotation);\r\n      */\r\n      return;\r\n    }\r\n\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().editAnnotation(documentId, annotationId, annotation);\r\n  });\r\n\r\n  setTimeout(() => {\r\n    isDragging = false;\r\n  }, 0);\r\n\r\n  overlay.style.background = '';\r\n  overlay.style.cursor = '';\r\n\r\n  document.removeEventListener('mousemove', handleDocumentMousemove);\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"enableUserSelect\"])();\r\n}\r\n\r\n/**\r\n * Handle annotation.click event\r\n *\r\n * @param {Element} e The annotation element that was clicked\r\n */\r\nfunction handleAnnotationClick(target) {\r\n  createEditOverlay(target);\r\n}\r\n\r\n/**\r\n * Enable edit mode behavior.\r\n */\r\nfunction enableEdit() {\r\n  if (_enabled) {\r\n    return;\r\n  }\r\n\r\n  _enabled = true;\r\n  Object(_event__WEBPACK_IMPORTED_MODULE_2__[\"addEventListener\"])('annotation:click', handleAnnotationClick);\r\n};\r\n\r\n/**\r\n * Disable edit mode behavior.\r\n */\r\nfunction disableEdit() {\r\n  destroyEditOverlay();\r\n\r\n  if (!_enabled) {\r\n    return;\r\n  }\r\n\r\n  _enabled = false;\r\n  Object(_event__WEBPACK_IMPORTED_MODULE_2__[\"removeEventListener\"])('annotation:click', handleAnnotationClick);\r\n};\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/edit.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/eraser.js":
/*!*******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/eraser.js ***!
  \*******************************************************/
/*! exports provided: enableEraser, disableEraser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableEraser\", function() { return enableEraser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableEraser\", function() { return disableEraser; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\nlet _canerase = false;\r\nlet previousPoint = null;\r\n\r\n/**\r\n *\r\n * @param {PointerEvent} e DOM event to handle\r\n */\r\nfunction handleDocumentDown(e) {\r\n  _canerase = true;\r\n  previousPoint = [e.clientX, e.clientY];\r\n}\r\n\r\n/**\r\n *\r\n * @param {PointerEvent} e DOM event to handle\r\n */\r\nfunction handleDocumentUp(e) {\r\n  _canerase = false;\r\n  erase(Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"findAnnotationAtPoint\"])(e.clientX, e.clientY));\r\n}\r\n\r\n/**\r\n *\r\n * @param {PointerEvent} e DOM event to handle\r\n */\r\nfunction handleDocumentMouseMove(e) {\r\n  if (!_canerase) {\r\n    return;\r\n  }\r\n\r\n  // This algorithm attempts to get the various points between the last\r\n  // PointerEvent and this one\r\n  let check = [];\r\n  let diffX = Math.abs(previousPoint[0] - e.clientX);\r\n  let diffY = Math.abs(previousPoint[1] - e.clientY);\r\n  if (diffX >= 1 || diffY >= 1) {\r\n    let maxSteps = Math.round(Math.max(diffX, diffY));\r\n    let subStepSize = Math.min(diffX, diffY) / maxSteps;\r\n    let smallerTest = diffX < diffY;\r\n    let startPoint = [\r\n      Math.min(previousPoint[0], e.clientX),\r\n      Math.min(previousPoint[1], e.clientY)\r\n    ];\r\n    for (let i = 0; i < maxSteps; i++) {\r\n      if (smallerTest) {\r\n        check.push([Math.round(startPoint[0] + (subStepSize * i)), Math.round(startPoint[1] + i)]);\r\n      }\r\n      else {\r\n        check.push([Math.round(startPoint[0] + i), Math.round(startPoint[1] + (subStepSize * i))]);\r\n      }\r\n    }\r\n  }\r\n  for (let point of check) {\r\n    erase(Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"findAnnotationAtPoint\"])(point[0], point[1]));\r\n  }\r\n  previousPoint = [e.clientX, e.clientY];\r\n}\r\n\r\nfunction erase(target) {\r\n  if (!_canerase) {\r\n    return;\r\n  }\r\n\r\n  if (target) {\r\n    let { documentId } = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getMetadata\"])(target.parentElement);\r\n    let annotationId = target.getAttribute('data-pdf-annotate-id');\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().deleteAnnotation(documentId, annotationId).then(() => {\r\n      let nodes = document.querySelectorAll(`[data-pdf-annotate-id=\"${annotationId}\"]`);\r\n      [...nodes].forEach((n) => {\r\n        n.parentNode.removeChild(n);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nfunction enableEraser() {\r\n  document.addEventListener('pointermove', handleDocumentMouseMove);\r\n  document.addEventListener('pointerdown', handleDocumentDown);\r\n  document.addEventListener('pointerup', handleDocumentUp);\r\n}\r\n\r\nfunction disableEraser() {\r\n  document.removeEventListener('pointermove', handleDocumentMouseMove);\r\n  document.removeEventListener('pointerdown', handleDocumentDown);\r\n  document.removeEventListener('pointerup', handleDocumentUp);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/eraser.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/event.js":
/*!******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/event.js ***!
  \******************************************************/
/*! exports provided: fireEvent, addEventListener, removeEventListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fireEvent\", function() { return fireEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addEventListener\", function() { return addEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeEventListener\", function() { return removeEventListener; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\nconst emitter = new events__WEBPACK_IMPORTED_MODULE_0___default.a();\r\n\r\nlet clickNode;\r\n\r\n/**\r\n * Handle document.click event\r\n *\r\n * @param {Event} e The DOM event to be handled\r\n */\r\ndocument.addEventListener('click', function handleDocumentClick(e) {\r\n  if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"findSVGAtPoint\"])(e.clientX, e.clientY)) {\r\n    return;\r\n  }\r\n\r\n  let target = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"findAnnotationAtPoint\"])(e.clientX, e.clientY);\r\n\r\n  // Emit annotation:blur if clickNode is no longer clicked\r\n  if (clickNode && clickNode !== target) {\r\n    emitter.emit('annotation:blur', clickNode);\r\n  }\r\n\r\n  // Emit annotation:click if target was clicked\r\n  if (target) {\r\n    emitter.emit('annotation:click', target);\r\n  }\r\n\r\n  clickNode = target;\r\n});\r\n\r\n// let mouseOverNode;\r\n// document.addEventListener('mousemove', function handleDocumentMousemove(e) {\r\n//   let target = findAnnotationAtPoint(e.clientX, e.clientY);\r\n//\r\n//   // Emit annotation:mouseout if target was mouseout'd\r\n//   if (mouseOverNode && !target) {\r\n//     emitter.emit('annotation:mouseout', mouseOverNode);\r\n//   }\r\n//\r\n//   // Emit annotation:mouseover if target was mouseover'd\r\n//   if (target && mouseOverNode !== target) {\r\n//     emitter.emit('annotation:mouseover', target);\r\n//   }\r\n//\r\n//   mouseOverNode = target;\r\n// });\r\n\r\nfunction fireEvent() { emitter.emit(...arguments); };\r\nfunction addEventListener() { emitter.on(...arguments); };\r\nfunction removeEventListener() { emitter.removeListener(...arguments); };\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/event.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/index.js":
/*!******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ \"./node_modules/pdf-annotate.js/src/UI/event.js\");\n/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edit */ \"./node_modules/pdf-annotate.js/src/UI/edit.js\");\n/* harmony import */ var _pen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pen */ \"./node_modules/pdf-annotate.js/src/UI/pen.js\");\n/* harmony import */ var _arrow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./arrow */ \"./node_modules/pdf-annotate.js/src/UI/arrow.js\");\n/* harmony import */ var _eraser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./eraser */ \"./node_modules/pdf-annotate.js/src/UI/eraser.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point */ \"./node_modules/pdf-annotate.js/src/UI/point.js\");\n/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rect */ \"./node_modules/pdf-annotate.js/src/UI/rect.js\");\n/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./circle */ \"./node_modules/pdf-annotate.js/src/UI/circle.js\");\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./text */ \"./node_modules/pdf-annotate.js/src/UI/text.js\");\n/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./page */ \"./node_modules/pdf-annotate.js/src/UI/page.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  addEventListener: _event__WEBPACK_IMPORTED_MODULE_0__[\"addEventListener\"],\r\n  removeEventListener: _event__WEBPACK_IMPORTED_MODULE_0__[\"removeEventListener\"],\r\n  fireEvent: _event__WEBPACK_IMPORTED_MODULE_0__[\"fireEvent\"],\r\n\r\n  disableEdit: _edit__WEBPACK_IMPORTED_MODULE_1__[\"disableEdit\"],\r\n  enableEdit: _edit__WEBPACK_IMPORTED_MODULE_1__[\"enableEdit\"],\r\n\r\n  disablePen: _pen__WEBPACK_IMPORTED_MODULE_2__[\"disablePen\"],\r\n  enablePen: _pen__WEBPACK_IMPORTED_MODULE_2__[\"enablePen\"],\r\n  setPen: _pen__WEBPACK_IMPORTED_MODULE_2__[\"setPen\"],\r\n\r\n  disablePoint: _point__WEBPACK_IMPORTED_MODULE_5__[\"disablePoint\"],\r\n  enablePoint: _point__WEBPACK_IMPORTED_MODULE_5__[\"enablePoint\"],\r\n\r\n  disableRect: _rect__WEBPACK_IMPORTED_MODULE_6__[\"disableRect\"],\r\n  enableRect: _rect__WEBPACK_IMPORTED_MODULE_6__[\"enableRect\"],\r\n\r\n  disableCircle: _circle__WEBPACK_IMPORTED_MODULE_7__[\"disableCircle\"],\r\n  enableCircle: _circle__WEBPACK_IMPORTED_MODULE_7__[\"enableCircle\"],\r\n  setCircle: _circle__WEBPACK_IMPORTED_MODULE_7__[\"setCircle\"],\r\n  addCircle: _circle__WEBPACK_IMPORTED_MODULE_7__[\"addCircle\"],\r\n\r\n  disableArrow: _arrow__WEBPACK_IMPORTED_MODULE_3__[\"disableArrow\"],\r\n  enableArrow: _arrow__WEBPACK_IMPORTED_MODULE_3__[\"enableArrow\"],\r\n  setArrow: _arrow__WEBPACK_IMPORTED_MODULE_3__[\"setArrow\"],\r\n\r\n  disableEraser: _eraser__WEBPACK_IMPORTED_MODULE_4__[\"disableEraser\"],\r\n  enableEraser: _eraser__WEBPACK_IMPORTED_MODULE_4__[\"enableEraser\"],\r\n\r\n  disableText: _text__WEBPACK_IMPORTED_MODULE_8__[\"disableText\"],\r\n  enableText: _text__WEBPACK_IMPORTED_MODULE_8__[\"enableText\"],\r\n  setText: _text__WEBPACK_IMPORTED_MODULE_8__[\"setText\"],\r\n\r\n  createPage: _page__WEBPACK_IMPORTED_MODULE_9__[\"createPage\"],\r\n  renderPage: _page__WEBPACK_IMPORTED_MODULE_9__[\"renderPage\"]\r\n});\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/index.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/page.js":
/*!*****************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/page.js ***!
  \*****************************************************/
/*! exports provided: createPage, renderPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPage\", function() { return createPage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderPage\", function() { return renderPage; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./node_modules/pdf-annotate.js/src/config.js\");\n/* harmony import */ var _a11y_renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../a11y/renderScreenReaderHints */ \"./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderHints.js\");\n\r\n\r\n\r\n\r\n// Template for creating a new page\r\nconst PAGE_TEMPLATE = `\r\n  <div style=\"visibility: hidden;\" class=\"page\" data-loaded=\"false\">\r\n    <div class=\"canvasWrapper\">\r\n      <canvas></canvas>\r\n    </div>\r\n    <svg class=\"` + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationLayerName + `\"></svg>\r\n    <div class=\"` + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].textLayerName + `\"></div>\r\n  </div>\r\n`;\r\n\r\n/**\r\n * Create a new page to be appended to the DOM.\r\n *\r\n * @param {Number} pageNumber The page number that is being created\r\n * @return {HTMLElement}\r\n */\r\nfunction createPage(pageNumber) {\r\n  let temp = document.createElement('div');\r\n  temp.innerHTML = PAGE_TEMPLATE;\r\n\r\n  let page = temp.children[0];\r\n  let canvas = page.querySelector('canvas');\r\n\r\n  page.setAttribute('id', `pageContainer${pageNumber}`);\r\n  page.setAttribute('data-page-number', pageNumber);\r\n\r\n  canvas.mozOpaque = true;\r\n  canvas.setAttribute('id', `page${pageNumber}`);\r\n\r\n  return page;\r\n}\r\n\r\n/**\r\n * Render a page that has already been created.\r\n *\r\n * @param {Number} pageNumber The page number to be rendered\r\n * @param {Object} renderOptions The options for rendering\r\n * @return {Promise} Settled once rendering has completed\r\n *  A settled Promise will be either:\r\n *    - fulfilled: [pdfPage, annotations]\r\n *    - rejected: Error\r\n */\r\nfunction renderPage(pageNumber, renderOptions) {\r\n  let {\r\n    documentId,\r\n    pdfDocument,\r\n    scale,\r\n    rotate\r\n  } = renderOptions;\r\n\r\n  // Load the page and annotations\r\n  return Promise.all([\r\n    pdfDocument.getPage(pageNumber),\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAnnotations(documentId, pageNumber)\r\n  ]).then(([pdfPage, annotations]) => {\r\n    let page = document.getElementById(`pageContainer${pageNumber}`);\r\n    let svg = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationClassQuery());\r\n    let canvas = page.querySelector('.canvasWrapper canvas');\r\n    let canvasContext = canvas.getContext('2d', {alpha: false});\r\n    let totalRotation = (rotate + pdfPage.rotate) % 360;\r\n    let viewport = pdfPage.getViewport({scale: scale, rotation: totalRotation});\r\n    let transform = scalePage(pageNumber, viewport, canvasContext);\r\n\r\n    // Render the page\r\n    return Promise.all([\r\n      pdfPage.render({ canvasContext, viewport, transform }).promise,\r\n      _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].render(svg, viewport, annotations)\r\n    ]).then(() => {\r\n      // Text content is needed for a11y, but is also necessary for creating\r\n      // highlight and strikeout annotations which require selecting text.\r\n      return pdfPage.getTextContent({normalizeWhitespace: true}).then((textContent) => {\r\n        return new Promise((resolve, reject) => {\r\n          // Render text layer for a11y of text content\r\n          let textLayer = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].textClassQuery());\r\n          let textLayerFactory = new pdfjsViewer.DefaultTextLayerFactory();\r\n          let textLayerBuilder = textLayerFactory.createTextLayerBuilder(textLayer, pageNumber - 1, viewport);\r\n          textLayerBuilder.setTextContent(textContent);\r\n          textLayerBuilder.render();\r\n\r\n          // Enable a11y for annotations\r\n          // Timeout is needed to wait for `textLayerBuilder.render`\r\n          setTimeout(() => {\r\n            try {\r\n              Object(_a11y_renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(annotations.annotations);\r\n              resolve();\r\n            }\r\n            catch (e) {\r\n              reject(e);\r\n            }\r\n          });\r\n        });\r\n      });\r\n    }).then(() => {\r\n      // Indicate that the page was loaded\r\n      page.setAttribute('data-loaded', 'true');\r\n\r\n      return [pdfPage, annotations];\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Scale the elements of a page.\r\n *\r\n * @param {Number} pageNumber The page number to be scaled\r\n * @param {Object} viewport The viewport of the PDF page (see pdfPage.getViewport(scale, rotate))\r\n * @param {Object} context The canvas context that the PDF page is rendered to\r\n * @return {Array} The transform data for rendering the PDF page\r\n */\r\nfunction scalePage(pageNumber, viewport, context) {\r\n  let page = document.getElementById(`pageContainer${pageNumber}`);\r\n  let canvas = page.querySelector('.canvasWrapper canvas');\r\n  let svg = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationClassQuery());\r\n  let wrapper = page.querySelector('.canvasWrapper');\r\n  let textLayer = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].textClassQuery());\r\n  let outputScale = getOutputScale(context);\r\n  let transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];\r\n  let sfx = approximateFraction(outputScale.sx);\r\n  let sfy = approximateFraction(outputScale.sy);\r\n\r\n  // Adjust width/height for scale\r\n  page.style.visibility = '';\r\n  canvas.width = roundToDivide(viewport.width * outputScale.sx, sfx[0]);\r\n  canvas.height = roundToDivide(viewport.height * outputScale.sy, sfy[0]);\r\n  canvas.style.width = roundToDivide(viewport.width, sfx[1]) + 'px';\r\n  canvas.style.height = roundToDivide(viewport.height, sfx[1]) + 'px';\r\n  svg.setAttribute('width', viewport.width);\r\n  svg.setAttribute('height', viewport.height);\r\n  svg.style.width = `${viewport.width}px`;\r\n  svg.style.height = `${viewport.height}px`;\r\n  page.style.width = `${viewport.width}px`;\r\n  page.style.height = `${viewport.height}px`;\r\n  wrapper.style.width = `${viewport.width}px`;\r\n  wrapper.style.height = `${viewport.height}px`;\r\n  textLayer.style.width = `${viewport.width}px`;\r\n  textLayer.style.height = `${viewport.height}px`;\r\n\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Approximates a float number as a fraction using Farey sequence (max order of 8).\r\n *\r\n * @param {Number} x Positive float number\r\n * @return {Array} Estimated fraction: the first array item is a numerator,\r\n *                 the second one is a denominator.\r\n */\r\nfunction approximateFraction(x) {\r\n  // Fast path for int numbers or their inversions.\r\n  if (Math.floor(x) === x) {\r\n    return [x, 1];\r\n  }\r\n\r\n  const xinv = 1 / x;\r\n  const limit = 8;\r\n  if (xinv > limit) {\r\n    return [1, limit];\r\n  }\r\n  else if (Math.floor(xinv) === xinv) {\r\n    return [1, xinv];\r\n  }\r\n\r\n  const x_ = x > 1 ? xinv : x;\r\n\r\n  // a/b and c/d are neighbours in Farey sequence.\r\n  let a = 0; let b = 1; let c = 1; let d = 1;\r\n\r\n  // Limit search to order 8.\r\n  while (true) {\r\n    // Generating next term in sequence (order of q).\r\n    let p = a + c; let q = b + d;\r\n    if (q > limit) {\r\n      break;\r\n    }\r\n    if (x_ <= p / q) {\r\n      c = p; d = q;\r\n    }\r\n    else {\r\n      a = p; b = q;\r\n    }\r\n  }\r\n\r\n  // Select closest of neighbours to x.\r\n  if (x_ - a / b < c / d - x_) {\r\n    return x_ === x ? [a, b] : [b, a];\r\n  }\r\n  else {\r\n    return x_ === x ? [c, d] : [d, c];\r\n  }\r\n}\r\n\r\nfunction getOutputScale(ctx) {\r\n  let devicePixelRatio = window.devicePixelRatio || 1;\r\n  let backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\r\n                          ctx.mozBackingStorePixelRatio ||\r\n                          ctx.msBackingStorePixelRatio ||\r\n                          ctx.oBackingStorePixelRatio ||\r\n                          ctx.backingStorePixelRatio || 1;\r\n  let pixelRatio = devicePixelRatio / backingStoreRatio;\r\n  return {\r\n    sx: pixelRatio,\r\n    sy: pixelRatio,\r\n    scaled: pixelRatio !== 1\r\n  };\r\n}\r\n\r\nfunction roundToDivide(x, div) {\r\n  let r = x % div;\r\n  return r === 0 ? x : Math.round(x - r + div);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/page.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/pen.js":
/*!****************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/pen.js ***!
  \****************************************************/
/*! exports provided: setPen, getPen, enablePen, disablePen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setPen\", function() { return setPen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPen\", function() { return getPen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enablePen\", function() { return enablePen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disablePen\", function() { return disablePen; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet _candraw = false;\r\nlet _penSize;\r\nlet _penColor;\r\nlet path;\r\nlet lines = [];\r\n\r\n/**\r\n * Handle document.touchdown or document.pointerdown event\r\n * @param {PointerEvent} e The DOM event to be handled\r\n */\r\nfunction handleDocumentPointerdown(e) {\r\n  path = null;\r\n  lines = [];\r\n  _candraw = true;\r\n  /* if (!e.srcElement.classList.contains('annotationLayer')) {\r\n    return;\r\n  } */\r\n  e.preventDefault();\r\n}\r\n\r\n/**\r\n * Handle document.pointerup event\r\n *\r\n * @param {PointerEvent} e The DOM event to be handled\r\n */\r\nfunction handleDocumentPointerup(e) {\r\n  saveToStorage(e.clientX, e.clientY);\r\n}\r\n\r\nfunction saveToStorage(x, y) {\r\n  _candraw = false;\r\n  let svg;\r\n  if (lines.length > 1 && (svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(x, y))) {\r\n    let { documentId, pageNumber } = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getMetadata\"])(svg);\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addAnnotation(documentId, pageNumber, {\r\n      type: 'drawing',\r\n      width: _penSize,\r\n      color: _penColor,\r\n      lines\r\n    }).then((annotation) => {\r\n      if (path) {\r\n        svg.removeChild(path);\r\n      }\r\n\r\n      Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, annotation);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.mousemove event\r\n *\r\n * @param {PointerEvent} e The DOM event to be handled\r\n */\r\nfunction handleDocumentPointermove(e) {\r\n  // if (!e.srcElement.classList.contains('annotationLayer')) {\r\n  //   return;\r\n  // }\r\n  if (_candraw) {\r\n    savePoint(e.clientX, e.clientY);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.keyup event\r\n *\r\n * @param {KeyboardEvent} e The DOM event to be handled\r\n * } e The DOM event to be handled\r\n */\r\nfunction handleDocumentKeyup(e) {\r\n  // Cancel rect if Esc is pressed\r\n  if (e.keyCode === 27) {\r\n    lines = null;\r\n    path.parentNode.removeChild(path);\r\n    document.removeEventListener('pointermove', handleDocumentPointermove);\r\n    document.removeEventListener('pointerup', handleDocumentPointerup);\r\n  }\r\n}\r\n\r\n/**\r\n * Save a point to the line being drawn.\r\n *\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n */\r\nfunction savePoint(x, y) {\r\n  let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(x, y);\r\n  if (!svg) {\r\n    return;\r\n  }\r\n\r\n  let rect = svg.getBoundingClientRect();\r\n  let point = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"convertToSvgPoint\"])([\r\n    x - rect.left,\r\n    y - rect.top\r\n  ], svg);\r\n  point[0] = point[0].toFixed(2);\r\n  point[1] = point[1].toFixed(2);\r\n  lines.push(point);\r\n\r\n  if (lines.length <= 1) {\r\n    return;\r\n  }\r\n\r\n  if (path) {\r\n    svg.removeChild(path);\r\n  }\r\n\r\n  path = Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, {\r\n    type: 'drawing',\r\n    color: _penColor,\r\n    width: _penSize,\r\n    lines\r\n  });\r\n}\r\n\r\n/**\r\n * Set the attributes of the pen.\r\n *\r\n * @param {Number} penSize The size of the lines drawn by the pen, rounded to 2 decimal places\r\n * @param {String} penColor The color of the lines drawn by the pen\r\n */\r\nfunction setPen(penSize = 1, penColor = '000000') {\r\n  _penSize = Math.round(parseFloat(penSize) * 1e2) / 1e2;\r\n  _penColor = penColor;\r\n}\r\n\r\n/**\r\n * Return pen attributes of the pen\r\n *\r\n * @return {Object} Object with size and color\r\n */\r\nfunction getPen() {\r\n  return {\r\n    size: _penSize,\r\n    color: _penColor\r\n  };\r\n}\r\n\r\n/**\r\n * Enable the pen behavior\r\n */\r\nfunction enablePen() {\r\n  if (_enabled) {\r\n    return;\r\n  }\r\n\r\n  _enabled = true;\r\n  // Chrome and Firefox has different behaviors with how pen works, so we need different events.\r\n  document.addEventListener('pointerdown', handleDocumentPointerdown);\r\n  document.addEventListener('pointermove', handleDocumentPointermove);\r\n  document.addEventListener('pointerup', handleDocumentPointerup);\r\n\r\n  document.addEventListener('keyup', handleDocumentKeyup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"disableUserSelect\"])();\r\n}\r\n\r\n/**\r\n * Disable the pen behavior\r\n */\r\nfunction disablePen() {\r\n  if (!_enabled) {\r\n    return;\r\n  }\r\n\r\n  _enabled = false;\r\n  document.removeEventListener('pointerdown', handleDocumentPointerdown);\r\n  document.removeEventListener('pointermove', handleDocumentPointermove);\r\n  document.removeEventListener('pointerup', handleDocumentPointerup);\r\n\r\n  document.removeEventListener('keyup', handleDocumentKeyup);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"enableUserSelect\"])();\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/pen.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/point.js":
/*!******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/point.js ***!
  \******************************************************/
/*! exports provided: enablePoint, disablePoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enablePoint\", function() { return enablePoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disablePoint\", function() { return disablePoint; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet input;\r\n\r\n/**\r\n * Handle document.mouseup event\r\n *\r\n * @param {Event} The DOM event to be handled\r\n */\r\nfunction handleDocumentMouseup(e) {\r\n  if (input || !Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(e.clientX, e.clientY)) {\r\n    return;\r\n  }\r\n\r\n  input = document.createElement('input');\r\n  input.setAttribute('id', 'pdf-annotate-point-input');\r\n  input.setAttribute('placeholder', 'Enter comment');\r\n  input.style.border = `3px solid ${_utils__WEBPACK_IMPORTED_MODULE_2__[\"BORDER_COLOR\"]}`;\r\n  input.style.borderRadius = '3px';\r\n  input.style.position = 'absolute';\r\n  input.style.top = `${e.clientY}px`;\r\n  input.style.left = `${e.clientX}px`;\r\n\r\n  input.addEventListener('blur', handleInputBlur);\r\n  input.addEventListener('keyup', handleInputKeyup);\r\n\r\n  document.body.appendChild(input);\r\n  input.focus();\r\n}\r\n\r\n/**\r\n * Handle input.blur event\r\n */\r\nfunction handleInputBlur() {\r\n  savePoint();\r\n}\r\n\r\n/**\r\n * Handle input.keyup event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleInputKeyup(e) {\r\n  if (e.keyCode === 27) {\r\n    closeInput();\r\n  }\r\n  else if (e.keyCode === 13) {\r\n    savePoint();\r\n  }\r\n}\r\n\r\n/**\r\n * Save a new point annotation from input\r\n */\r\nfunction savePoint() {\r\n  if (input.value.trim().length > 0) {\r\n    let clientX = parseInt(input.style.left, 10);\r\n    let clientY = parseInt(input.style.top, 10);\r\n    let content = input.value.trim();\r\n    let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(clientX, clientY);\r\n    if (!svg) {\r\n      return;\r\n    }\r\n\r\n    let rect = svg.getBoundingClientRect();\r\n    let { documentId, pageNumber } = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getMetadata\"])(svg);\r\n    let annotation = Object.assign({\r\n      type: 'point'\r\n    }, Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"scaleDown\"])(svg, {\r\n      x: clientX - rect.left,\r\n      y: clientY - rect.top\r\n    }));\r\n\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)\r\n      .then((annotation) => {\r\n        _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addComment(\r\n          documentId,\r\n          annotation.uuid,\r\n          content\r\n        );\r\n\r\n        Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, annotation);\r\n      });\r\n  }\r\n\r\n  closeInput();\r\n}\r\n\r\n/**\r\n * Close the input element\r\n */\r\nfunction closeInput() {\r\n  input.removeEventListener('blur', handleInputBlur);\r\n  input.removeEventListener('keyup', handleInputKeyup);\r\n  document.body.removeChild(input);\r\n  input = null;\r\n}\r\n\r\n/**\r\n * Enable point annotation behavior\r\n */\r\nfunction enablePoint() {\r\n  if (_enabled) { return; }\r\n\r\n  _enabled = true;\r\n  document.addEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\n/**\r\n * Disable point annotation behavior\r\n */\r\nfunction disablePoint() {\r\n  if (!_enabled) { return; }\r\n\r\n  _enabled = false;\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/point.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/rect.js":
/*!*****************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/rect.js ***!
  \*****************************************************/
/*! exports provided: enableRect, disableRect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableRect\", function() { return enableRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableRect\", function() { return disableRect; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./node_modules/pdf-annotate.js/src/config.js\");\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet _type;\r\nlet overlay;\r\nlet originY;\r\nlet originX;\r\n\r\n/**\r\n * Get the current window selection as rects\r\n *\r\n * @return {Array} An Array of rects\r\n */\r\nfunction getSelectionRects() {\r\n  try {\r\n    let selection = window.getSelection();\r\n    let range = selection.getRangeAt(0);\r\n    let rects = range.getClientRects();\r\n\r\n    if (rects.length > 0 &&\r\n        rects[0].width > 0 &&\r\n        rects[0].height > 0) {\r\n      return rects;\r\n    }\r\n  }\r\n  catch (e) {}\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Handle document.mousedown event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleDocumentMousedown(e) {\r\n  let svg;\r\n  if (_type !== 'area' || !(svg = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"findSVGAtPoint\"])(e.clientX, e.clientY))) {\r\n    return;\r\n  }\r\n\r\n  let rect = svg.getBoundingClientRect();\r\n  originY = e.clientY;\r\n  originX = e.clientX;\r\n\r\n  overlay = document.createElement('div');\r\n  overlay.style.position = 'absolute';\r\n  overlay.style.top = `${originY - rect.top}px`;\r\n  overlay.style.left = `${originX - rect.left}px`;\r\n  overlay.style.border = `3px solid ${_utils__WEBPACK_IMPORTED_MODULE_3__[\"BORDER_COLOR\"]}`;\r\n  overlay.style.borderRadius = '3px';\r\n  svg.parentNode.appendChild(overlay);\r\n\r\n  document.addEventListener('mousemove', handleDocumentMousemove);\r\n  Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"disableUserSelect\"])();\r\n}\r\n\r\n/**\r\n * Handle document.mousemove event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleDocumentMousemove(e) {\r\n  let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationSvgQuery());\r\n  let rect = svg.getBoundingClientRect();\r\n\r\n  if (originX + (e.clientX - originX) < rect.right) {\r\n    overlay.style.width = `${e.clientX - originX}px`;\r\n  }\r\n\r\n  if (originY + (e.clientY - originY) < rect.bottom) {\r\n    overlay.style.height = `${e.clientY - originY}px`;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.mouseup event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleDocumentMouseup(e) {\r\n  let rects;\r\n  if (_type !== 'area' && (rects = getSelectionRects())) {\r\n    saveRect(_type, [...rects].map((r) => {\r\n      return {\r\n        top: r.top,\r\n        left: r.left,\r\n        width: r.width,\r\n        height: r.height\r\n      };\r\n    }));\r\n  }\r\n  else if (_type === 'area' && overlay) {\r\n    let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].annotationSvgQuery());\r\n    let rect = svg.getBoundingClientRect();\r\n    saveRect(_type, [{\r\n      top: parseInt(overlay.style.top, 10) + rect.top,\r\n      left: parseInt(overlay.style.left, 10) + rect.left,\r\n      width: parseInt(overlay.style.width, 10),\r\n      height: parseInt(overlay.style.height, 10)\r\n    }]);\r\n\r\n    overlay.parentNode.removeChild(overlay);\r\n    overlay = null;\r\n\r\n    document.removeEventListener('mousemove', handleDocumentMousemove);\r\n    Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"enableUserSelect\"])();\r\n  }\r\n}\r\n\r\n/**\r\n * Handle document.keyup event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleDocumentKeyup(e) {\r\n  // Cancel rect if Esc is pressed\r\n  if (e.keyCode === 27) {\r\n    let selection = window.getSelection();\r\n    selection.removeAllRanges();\r\n    if (overlay && overlay.parentNode) {\r\n      overlay.parentNode.removeChild(overlay);\r\n      overlay = null;\r\n      document.removeEventListener('mousemove', handleDocumentMousemove);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Save a rect annotation\r\n *\r\n * @param {String} type The type of rect (area, highlight, strikeout)\r\n * @param {Array} rects The rects to use for annotation\r\n * @param {String} color The color of the rects\r\n */\r\nfunction saveRect(type, rects, color) {\r\n  let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"findSVGAtPoint\"])(rects[0].left, rects[0].top);\r\n  let annotation;\r\n\r\n  if (!svg) {\r\n    return;\r\n  }\r\n\r\n  let boundingRect = svg.getBoundingClientRect();\r\n\r\n  if (!color) {\r\n    if (type === 'highlight') {\r\n      color = 'FFFF00';\r\n    }\r\n    else if (type === 'strikeout') {\r\n      color = 'FF0000';\r\n    }\r\n  }\r\n\r\n  // Initialize the annotation\r\n  annotation = {\r\n    type,\r\n    color,\r\n    rectangles: [...rects].map((r) => {\r\n      let offset = 0;\r\n\r\n      if (type === 'strikeout') {\r\n        offset = r.height / 2;\r\n      }\r\n\r\n      return Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"convertToSvgRect\"])({\r\n        y: (r.top + offset) - boundingRect.top,\r\n        x: r.left - boundingRect.left,\r\n        width: r.width,\r\n        height: r.height\r\n      }, svg);\r\n    }).filter((r) => r.width > 0 && r.height > 0 && r.x > -1 && r.y > -1)\r\n  };\r\n\r\n  // Short circuit if no rectangles exist\r\n  if (annotation.rectangles.length === 0) {\r\n    return;\r\n  }\r\n\r\n  // Special treatment for area as it only supports a single rect\r\n  if (type === 'area') {\r\n    let rect = annotation.rectangles[0];\r\n    delete annotation.rectangles;\r\n    annotation.x = rect.x;\r\n    annotation.y = rect.y;\r\n    annotation.width = rect.width;\r\n    annotation.height = rect.height;\r\n  }\r\n\r\n  let { documentId, pageNumber } = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"getMetadata\"])(svg);\r\n\r\n  // Add the annotation\r\n  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)\r\n    .then((annotation) => {\r\n      Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_2__[\"appendChild\"])(svg, annotation);\r\n    });\r\n}\r\n\r\n/**\r\n * Enable rect behavior\r\n */\r\nfunction enableRect(type) {\r\n  _type = type;\r\n\r\n  if (_enabled) { return; }\r\n\r\n  _enabled = true;\r\n  document.addEventListener('mouseup', handleDocumentMouseup);\r\n  document.addEventListener('mousedown', handleDocumentMousedown);\r\n  document.addEventListener('keyup', handleDocumentKeyup);\r\n}\r\n\r\n/**\r\n * Disable rect behavior\r\n */\r\nfunction disableRect() {\r\n  if (!_enabled) { return; }\r\n\r\n  _enabled = false;\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n  document.removeEventListener('mousedown', handleDocumentMousedown);\r\n  document.removeEventListener('keyup', handleDocumentKeyup);\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/rect.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/text.js":
/*!*****************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/text.js ***!
  \*****************************************************/
/*! exports provided: setText, enableText, disableText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setText\", function() { return setText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableText\", function() { return enableText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableText\", function() { return disableText; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\nlet _enabled = false;\r\nlet input;\r\nlet _textSize;\r\nlet _textColor;\r\n\r\n/**\r\n * Handle document.mouseup event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleDocumentMouseup(e) {\r\n  if (input || !Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(e.clientX, e.clientY)) {\r\n    return;\r\n  }\r\n  // if (!e.srcElement.classList.contains('annotationLayer')) {\r\n  //   return;\r\n  // }\r\n  input = document.createElement('input');\r\n  input.setAttribute('id', 'pdf-annotate-text-input');\r\n  input.setAttribute('placeholder', 'Enter text');\r\n  input.style.border = `3px solid ${_utils__WEBPACK_IMPORTED_MODULE_2__[\"BORDER_COLOR\"]}`;\r\n  input.style.borderRadius = '3px';\r\n  input.style.position = 'absolute';\r\n  input.style.top = `${e.clientY}px`;\r\n  input.style.left = `${e.clientX}px`;\r\n  input.style.fontSize = `${_textSize}px`;\r\n  input.style.zIndex = '41';\r\n  input.addEventListener('blur', handleInputBlur);\r\n  input.addEventListener('keyup', handleInputKeyup);\r\n\r\n  document.body.appendChild(input);\r\n  input.focus();\r\n}\r\n\r\n/**\r\n * Handle input.blur event\r\n */\r\nfunction handleInputBlur() {\r\n  saveText();\r\n}\r\n\r\n/**\r\n * Handle input.keyup event\r\n *\r\n * @param {Event} e The DOM event to handle\r\n */\r\nfunction handleInputKeyup(e) {\r\n  if (e.keyCode === 27) {\r\n    closeInput();\r\n  }\r\n  else if (e.keyCode === 13) {\r\n    saveText();\r\n  }\r\n}\r\n\r\n/**\r\n * Save a text annotation from input\r\n */\r\nfunction saveText() {\r\n  let value = (input.value) ? input.value.replace(/ +$/, '') : '';\r\n  if (value.length > 0) {\r\n    let clientX = parseInt(input.style.left, 10);\r\n    let clientY = parseInt(input.style.top, 10);\r\n    let svg = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"findSVGAtPoint\"])(clientX, clientY);\r\n    if (!svg) {\r\n      return;\r\n    }\r\n    let height = _textSize;\r\n    let { documentId, pageNumber, viewport } = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getMetadata\"])(svg);\r\n    let scale = 1 / viewport.scale;\r\n    let rect = svg.getBoundingClientRect();\r\n    let pt = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"convertToSvgPoint\"])([\r\n      clientX - rect.left,\r\n      clientY - rect.top + height], svg, viewport);\r\n    let annotation = {\r\n      type: 'textbox',\r\n      size: _textSize * scale,\r\n      color: _textColor,\r\n      content: value,\r\n      x: pt[0],\r\n      y: pt[1],\r\n      rotation: -viewport.rotation\r\n    };\r\n\r\n    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)\r\n      .then((annotation) => {\r\n        Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_1__[\"appendChild\"])(svg, annotation);\r\n      });\r\n  }\r\n\r\n  closeInput();\r\n}\r\n\r\n/**\r\n * Close the input\r\n */\r\nfunction closeInput() {\r\n  if (input) {\r\n    input.removeEventListener('blur', handleInputBlur);\r\n    input.removeEventListener('keyup', handleInputKeyup);\r\n    document.body.removeChild(input);\r\n    input = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Set the text attributes\r\n *\r\n * @param {Number} textSize The size of the text\r\n * @param {String} textColor The color of the text\r\n */\r\nfunction setText(textSize = 12, textColor = '000000') {\r\n  _textSize = parseInt(textSize, 10);\r\n  _textColor = textColor;\r\n}\r\n\r\n/**\r\n * Enable text behavior\r\n */\r\nfunction enableText() {\r\n  if (_enabled) {\r\n    return;\r\n  }\r\n\r\n  _enabled = true;\r\n  document.addEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\n/**\r\n * Disable text behavior\r\n */\r\nfunction disableText() {\r\n  if (!_enabled) { return; }\r\n\r\n  _enabled = false;\r\n  document.removeEventListener('mouseup', handleDocumentMouseup);\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/text.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/UI/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/UI/utils.js ***!
  \******************************************************/
/*! exports provided: BORDER_COLOR, findSVGContainer, findSVGAtPoint, findAnnotationAtPoint, pointIntersectsRect, getOffsetAnnotationRect, scaleUp, convertToSvgRect, convertToSvgPoint, convertToScreenPoint, scaleDown, getScroll, getOffset, disableUserSelect, enableUserSelect, getMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BORDER_COLOR\", function() { return BORDER_COLOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findSVGContainer\", function() { return findSVGContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findSVGAtPoint\", function() { return findSVGAtPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findAnnotationAtPoint\", function() { return findAnnotationAtPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointIntersectsRect\", function() { return pointIntersectsRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOffsetAnnotationRect\", function() { return getOffsetAnnotationRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleUp\", function() { return scaleUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToSvgRect\", function() { return convertToSvgRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToSvgPoint\", function() { return convertToSvgPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToScreenPoint\", function() { return convertToScreenPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleDown\", function() { return scaleDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScroll\", function() { return getScroll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOffset\", function() { return getOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableUserSelect\", function() { return disableUserSelect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableUserSelect\", function() { return enableUserSelect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMetadata\", function() { return getMetadata; });\n/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n/* harmony import */ var _utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mathUtils */ \"./node_modules/pdf-annotate.js/src/utils/mathUtils.js\");\n\r\n\r\n\r\nconst BORDER_COLOR = '#00BFFF';\r\n\r\nconst userSelectStyleSheet = document.createElement('style');\r\nuserSelectStyleSheet.innerHTML = `\r\nbody {\r\n  -webkit-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n}\r\n`;\r\n\r\nuserSelectStyleSheet.setAttribute('data-pdf-annotate-user-select', 'true');\r\n\r\n/**\r\n * Find the SVGElement that contains all the annotations for a page\r\n *\r\n * @param {Element} node An annotation within that container\r\n * @return {SVGElement} The container SVG or null if it can't be found\r\n */\r\nfunction findSVGContainer(node) {\r\n  let parentNode = node;\r\n\r\n  while ((parentNode = parentNode.parentNode) &&\r\n          parentNode !== document) {\r\n    if (parentNode.nodeName.toUpperCase() === 'SVG' &&\r\n        parentNode.getAttribute('data-pdf-annotate-container') === 'true') {\r\n      return parentNode;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Find an SVGElement container at a given point\r\n *\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n * @return {SVGElement} The container SVG or null if one can't be found\r\n */\r\nfunction findSVGAtPoint(x, y) {\r\n  let elements = document.querySelectorAll('svg[data-pdf-annotate-container=\"true\"]');\r\n\r\n  for (let i = 0, l = elements.length; i < l; i++) {\r\n    let el = elements[i];\r\n    let rect = el.getBoundingClientRect();\r\n\r\n    if (pointIntersectsRect(x, y, rect)) {\r\n      return el;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Find an Element that represents an annotation at a given point.\r\n *\r\n * IMPORTANT: Requires the annotation layer to be the top most element so\r\n *            either use z-ordering or make it the leaf container.\r\n *\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n * @return {Element} The annotation element or null if one can't be found\r\n */\r\nfunction findAnnotationAtPoint(x, y) {\r\n  // let el = null;\r\n  // let candidate = document.elementFromPoint(x, y);\r\n  // while (!el && candidate && candidate !== document) {\r\n  //   let type = candidate.getAttribute('data-pdf-annotate-type');\r\n  //   if (type) {\r\n  //     el = candidate;\r\n  //   }\r\n  //   candidate = candidate.parentNode;\r\n  // }\r\n  // return el;\r\n  let svg = findSVGAtPoint(x, y);\r\n  if (!svg) { return; }\r\n  let elements = svg.querySelectorAll('[data-pdf-annotate-type]');\r\n\r\n  // Find a target element within SVG\r\n  for (let i=0, l=elements.length; i<l; i++) {\r\n    let el = elements[i];\r\n    if (pointIntersectsRect(x, y, getOffsetAnnotationRect(el))) {   \r\n      return el;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Determine if a point intersects a rect\r\n *\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n * @param {Object} rect The points of a rect (likely from getBoundingClientRect)\r\n * @return {Boolean} True if a collision occurs, otherwise false\r\n */\r\nfunction pointIntersectsRect(x, y, rect) {\r\n  return y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;\r\n}\r\n\r\n/**\r\n * Get the rect of an annotation element accounting for offset.\r\n *\r\n * @param {Element} el The element to get the rect of\r\n * @return {Object} The dimensions of the element\r\n */\r\nfunction getOffsetAnnotationRect(el) {\r\n  let rect = el.getBoundingClientRect();\r\n  let { width, height } = rect;\r\n  let extraOffsetWidth = 0;\r\n  let extraOffsetHeight = 0;\r\n  if (['line', 'path'].indexOf(el.tagName.toLowerCase()) > -1 && el.getBBox) {\r\n    let bbox = el.getBBox();\r\n    extraOffsetWidth = (rect.width - bbox.width) / 2;\r\n    extraOffsetHeight = (rect.height - bbox.height) / 2;\r\n    width = bbox.width;\r\n    height = bbox.height;\r\n  }\r\n  let { offsetLeft, offsetTop } = getOffset(el);\r\n  return {\r\n    top: rect.top - offsetTop + extraOffsetHeight,\r\n    left: rect.left - offsetLeft + extraOffsetWidth,\r\n    bottom: rect.bottom - offsetTop - extraOffsetHeight,\r\n    right: rect.right - offsetLeft - extraOffsetWidth,\r\n    width: width,\r\n    height: height\r\n  };\r\n}\r\n\r\n/**\r\n * Adjust scale from normalized scale (100%) to rendered scale.\r\n *\r\n * @param {SVGElement} svg The SVG to gather metadata from\r\n * @param {Object} rect A map of numeric values to scale\r\n * @return {Object} A copy of `rect` with values scaled up\r\n */\r\nfunction scaleUp(svg, rect) {\r\n  let result = {};\r\n  let { viewport } = getMetadata(svg);\r\n\r\n  Object.keys(rect).forEach((key) => {\r\n    result[key] = rect[key] * viewport.scale;\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction convertToSvgRect(rect, svg, viewport) {\r\n  let pt1 = [rect.x, rect.y];\r\n  let pt2 = [rect.x + rect.width, rect.y + rect.height];\r\n\r\n  pt1 = convertToSvgPoint(pt1, svg, viewport);\r\n  pt2 = convertToSvgPoint(pt2, svg, viewport);\r\n\r\n  return {\r\n    x: Math.min(pt1[0], pt2[0]),\r\n    y: Math.min(pt1[1], pt2[1]),\r\n    width: Math.abs(pt2[0] - pt1[0]),\r\n    height: Math.abs(pt2[1] - pt1[1])\r\n  };\r\n}\r\n\r\nfunction convertToSvgPoint(pt, svg, viewport) {\r\n  viewport = viewport || getMetadata(svg).viewport;\r\n\r\n  let xform = [ 1, 0, 0, 1, 0, 0 ];\r\n  xform = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"scale\"])(xform, viewport.scale, viewport.scale);\r\n  xform = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"rotate\"])(xform, viewport.rotation);\r\n\r\n  let offset = Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_0__[\"getTranslation\"])(viewport);\r\n  xform = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"translate\"])(xform, offset.x, offset.y);\r\n\r\n  return Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"applyInverseTransform\"])(pt, xform);\r\n}\r\n\r\nfunction convertToScreenPoint(pt, svg, viewport) {\r\n  viewport = viewport || getMetadata(svg).viewport;\r\n\r\n  let xform = [ 1, 0, 0, 1, 0, 0 ];\r\n  xform = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"scale\"])(xform, viewport.scale, viewport.scale);\r\n  xform = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"rotate\"])(xform, viewport.rotation);\r\n\r\n  let offset = Object(_render_appendChild__WEBPACK_IMPORTED_MODULE_0__[\"getTranslation\"])(viewport);\r\n  xform = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"translate\"])(xform, offset.x, offset.y);\r\n\r\n  return Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__[\"applyTransform\"])(pt, xform);\r\n}\r\n\r\n/**\r\n * Adjust scale from rendered scale to a normalized scale (100%).\r\n *\r\n * @param {SVGElement} svg The SVG to gather metadata from\r\n * @param {Object} rect A map of numeric values to scale\r\n * @return {Object} A copy of `rect` with values scaled down\r\n */\r\nfunction scaleDown(svg, rect) {\r\n  let result = {};\r\n  let { viewport } = getMetadata(svg);\r\n\r\n  Object.keys(rect).forEach((key) => {\r\n    result[key] = rect[key] / viewport.scale;\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get the scroll position of an element, accounting for parent elements\r\n *\r\n * @param {Element} el The element to get the scroll position for\r\n * @return {Object} The scrollTop and scrollLeft position\r\n */\r\nfunction getScroll(el) {\r\n  let scrollTop = 0;\r\n  let scrollLeft = 0;\r\n  let parentNode = el;\r\n\r\n  while ((parentNode = parentNode.parentNode) &&\r\n          parentNode !== document) {\r\n    scrollTop += parentNode.scrollTop;\r\n    scrollLeft += parentNode.scrollLeft;\r\n  }\r\n\r\n  return { scrollTop, scrollLeft };\r\n}\r\n\r\n/**\r\n * Get the offset position of an element, accounting for parent elements\r\n *\r\n * @param {Element} el The element to get the offset position for\r\n * @return {Object} The offsetTop and offsetLeft position\r\n */\r\nfunction getOffset(el) {\r\n  let parentNode = el;\r\n\r\n  while ((parentNode = parentNode.parentNode) &&\r\n          parentNode !== document) {\r\n    if (parentNode.nodeName.toUpperCase() === 'SVG') {\r\n      break;\r\n    }\r\n  }\r\n\r\n  let rect = parentNode.getBoundingClientRect();\r\n\r\n  return { offsetLeft: rect.left, offsetTop: rect.top };\r\n}\r\n\r\n/**\r\n * Disable user ability to select text on page\r\n */\r\nfunction disableUserSelect() {\r\n  if (!userSelectStyleSheet.parentNode) {\r\n    document.head.appendChild(userSelectStyleSheet);\r\n  }\r\n}\r\n\r\n/**\r\n * Enable user ability to select text on page\r\n */\r\nfunction enableUserSelect() {\r\n  if (userSelectStyleSheet.parentNode) {\r\n    userSelectStyleSheet.parentNode.removeChild(userSelectStyleSheet);\r\n  }\r\n}\r\n\r\n/**\r\n * Get the metadata for a SVG container\r\n *\r\n * @param {SVGElement} svg The SVG container to get metadata for\r\n */\r\nfunction getMetadata(svg) {\r\n  return {\r\n    documentId: svg.getAttribute('data-pdf-annotate-document'),\r\n    pageNumber: parseInt(svg.getAttribute('data-pdf-annotate-page'), 10),\r\n    viewport: JSON.parse(svg.getAttribute('data-pdf-annotate-viewport'))\r\n  };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/UI/utils.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/createScreenReaderOnly.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/createScreenReaderOnly.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createScreenReaderOnly; });\n/**\r\n * Create a node that is only visible to screen readers\r\n *\r\n * @param {String} content The text content that should be read by screen reader\r\n * @param {String} [annotationId] The ID of the annotation assocaited\r\n * @return {Element} An Element that is only visible to screen readers\r\n */\r\nfunction createScreenReaderOnly(content, annotationId) {\r\n  let node = document.createElement('div');\r\n  let text = document.createTextNode(content);\r\n  node.appendChild(text);\r\n  node.setAttribute('id', `pdf-annotate-screenreader-${annotationId}`);\r\n  node.style.position = 'absolute';\r\n  node.style.left = '-10000px';\r\n  node.style.top = 'auto';\r\n  node.style.width = '1px';\r\n  node.style.height = '1px';\r\n  node.style.overflow = 'hidden';\r\n  return node;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/createScreenReaderOnly.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/initEventHandlers.js":
/*!********************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/initEventHandlers.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return initEventHandlers; });\n/* harmony import */ var _renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderScreenReaderHints */ \"./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderHints.js\");\n/* harmony import */ var _insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertScreenReaderComment */ \"./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderComment.js\");\n/* harmony import */ var _renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderScreenReaderComments */ \"./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderComments.js\");\n/* harmony import */ var _UI_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../UI/event */ \"./node_modules/pdf-annotate.js/src/UI/event.js\");\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Initialize the event handlers for keeping screen reader hints synced with data\r\n */\r\nfunction initEventHandlers() {\r\n  Object(_UI_event__WEBPACK_IMPORTED_MODULE_3__[\"addEventListener\"])('annotation:add', (documentId, pageNumber, annotation) => {\r\n    reorderAnnotationsByType(documentId, pageNumber, annotation.type);\r\n  });\r\n  Object(_UI_event__WEBPACK_IMPORTED_MODULE_3__[\"addEventListener\"])('annotation:edit', (documentId, annotationId, annotation) => {\r\n    reorderAnnotationsByType(documentId, annotation.page, annotation.type);\r\n  });\r\n  Object(_UI_event__WEBPACK_IMPORTED_MODULE_3__[\"addEventListener\"])('annotation:delete', removeAnnotation);\r\n  Object(_UI_event__WEBPACK_IMPORTED_MODULE_3__[\"addEventListener\"])('comment:add', insertComment);\r\n  Object(_UI_event__WEBPACK_IMPORTED_MODULE_3__[\"addEventListener\"])('comment:delete', removeComment);\r\n}\r\n\r\n/**\r\n * Reorder the annotation numbers by annotation type\r\n *\r\n * @param {String} documentId The ID of the document\r\n * @param {Number} pageNumber The page number of the annotations\r\n * @param {Strig} type The annotation type\r\n */\r\nfunction reorderAnnotationsByType(documentId, pageNumber, type) {\r\n  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getStoreAdapter().getAnnotations(documentId, pageNumber)\r\n    .then((annotations) => {\r\n      return annotations.annotations.filter((a) => {\r\n        return a.type === type;\r\n      });\r\n    })\r\n    .then((annotations) => {\r\n      annotations.forEach((a) => {\r\n        removeAnnotation(documentId, a.uuid);\r\n      });\r\n\r\n      return annotations;\r\n    })\r\n    .then(_renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\r\n}\r\n\r\n/**\r\n * Remove the screen reader hint for an annotation\r\n *\r\n * @param {String} documentId The ID of the document\r\n * @param {String} annotationId The Id of the annotation\r\n */\r\nfunction removeAnnotation(documentId, annotationId) {\r\n  removeElementById(`pdf-annotate-screenreader-${annotationId}`);\r\n  removeElementById(`pdf-annotate-screenreader-${annotationId}-end`);\r\n}\r\n\r\n/**\r\n * Insert a screen reader hint for a comment\r\n *\r\n * @param {String} documentId The ID of the document\r\n * @param {String} annotationId The ID of tha assocated annotation\r\n * @param {Object} comment The comment to insert a hint for\r\n */\r\nfunction insertComment(documentId, annotationId, comment) {\r\n  let list = document.querySelector(`pdf-annotate-screenreader-comment-list-${annotationId}`);\r\n  let promise;\r\n\r\n  if (!list) {\r\n    promise = Object(_renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(documentId, annotationId, []).then(() => {\r\n      list = document.querySelector(`pdf-annotate-screenreader-comment-list-${annotationId}`);\r\n      return true;\r\n    });\r\n  }\r\n  else {\r\n    promise = Promise.resolve(true);\r\n  }\r\n\r\n  promise.then(() => {\r\n    Object(_insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(comment);\r\n  });\r\n}\r\n\r\n/**\r\n * Remove a screen reader hint for a comment\r\n *\r\n * @param {String} documentId The ID of the document\r\n * @param {String} commentId The ID of the comment\r\n */\r\nfunction removeComment(documentId, commentId) {\r\n  removeElementById(`pdf-annotate-screenreader-comment-${commentId}`);\r\n}\r\n\r\n/**\r\n * Remove an element from the DOM by it's ID if it exists\r\n *\r\n * @param {String} elementId The ID of the element to be removed\r\n */\r\nfunction removeElementById(elementId) {\r\n  let el = document.getElementById(elementId);\r\n  if (el) {\r\n    el.parentNode.removeChild(el);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/initEventHandlers.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/insertElementWithinChildren.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/insertElementWithinChildren.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return insertElementWithinChildren; });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./node_modules/pdf-annotate.js/src/config.js\");\n/* harmony import */ var _insertElementWithinElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertElementWithinElement */ \"./node_modules/pdf-annotate.js/src/a11y/insertElementWithinElement.js\");\n/* harmony import */ var _UI_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UI/utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Insert an element at a point within the document.\r\n * This algorithm will try to insert between elements if possible.\r\n * It will however use `insertElementWithinElement` if it is more accurate.\r\n *\r\n * @param {Element} el The element to be inserted\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n * @param {Number} pageNumber The page number to limit elements to\r\n * @return {Boolean} True if element was able to be inserted, otherwise false\r\n */\r\nfunction insertElementWithinChildren(el, x, y, pageNumber) {\r\n  // Try and use most accurate method of inserting within an element\r\n  if (Object(_insertElementWithinElement__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(el, x, y, pageNumber, true)) {\r\n    return true;\r\n  }\r\n\r\n  // Fall back to inserting between elements\r\n  let svg = document.querySelector(`svg[data-pdf-annotate-page=\"${pageNumber}\"]`);\r\n  let rect = svg.getBoundingClientRect();\r\n  let nodes = [...svg.parentNode.querySelectorAll(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].textClassQuery() + ' > div')];\r\n\r\n  y = Object(_UI_utils__WEBPACK_IMPORTED_MODULE_2__[\"scaleUp\"])(svg, {y}).y + rect.top;\r\n  x = Object(_UI_utils__WEBPACK_IMPORTED_MODULE_2__[\"scaleUp\"])(svg, {x}).x + rect.left;\r\n\r\n  // Find the best node to insert before\r\n  for (let i = 0, l = nodes.length; i < l; i++) {\r\n    let n = nodes[i];\r\n    let r = n.getBoundingClientRect();\r\n    if (y <= r.top) {\r\n      n.parentNode.insertBefore(el, n);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // If all else fails try to append to the bottom\r\n  let textLayer = svg.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].textClassQuery());\r\n  if (textLayer) {\r\n    let textRect = textLayer.getBoundingClientRect();\r\n    if (Object(_UI_utils__WEBPACK_IMPORTED_MODULE_2__[\"pointIntersectsRect\"])(x, y, textRect)) {\r\n      textLayer.appendChild(el);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/insertElementWithinChildren.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/insertElementWithinElement.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/insertElementWithinElement.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return insertElementWithinElement; });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./node_modules/pdf-annotate.js/src/config.js\");\n/* harmony import */ var _UI_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/utils */ \"./node_modules/pdf-annotate.js/src/UI/utils.js\");\n\r\n\r\n\r\n/**\r\n * Insert an element at a point within the document.\r\n * This algorithm will only insert within an element amidst it's text content.\r\n *\r\n * @param {Element} el The element to be inserted\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n * @param {Number} pageNumber The page number to limit elements to\r\n * @param {Boolean} insertBefore Whether the element is to be inserted before or after x\r\n * @return {Boolean} True if element was able to be inserted, otherwise false\r\n */\r\nfunction insertElementWithinElement(el, x, y, pageNumber, insertBefore) {\r\n  const OFFSET_ADJUST = 2;\r\n\r\n  // If inserting before adjust `x` by looking for element a few px to the right\r\n  // Otherwise adjust a few px to the left\r\n  // This is to allow a little tolerance by searching within the box, instead\r\n  // of getting a false negative by testing right on the border.\r\n  x = Math.max(x + (OFFSET_ADJUST * (insertBefore ? 1 : -1)), 0);\r\n\r\n  let node = textLayerElementFromPoint(x, y + OFFSET_ADJUST, pageNumber);\r\n  if (!node) {\r\n    return false;\r\n  }\r\n\r\n  // Now that node has been found inverse the adjustment for `x`.\r\n  // This is done to accomodate tolerance by cutting off on the outside of the\r\n  // text boundary, instead of missing a character by cutting off within.\r\n  x = x + (OFFSET_ADJUST * (insertBefore ? -1 : 1));\r\n\r\n  let svg = document.querySelector(`svg[data-pdf-annotate-page=\"${pageNumber}\"]`);\r\n  let left = Object(_UI_utils__WEBPACK_IMPORTED_MODULE_1__[\"scaleDown\"])(svg, {left: node.getBoundingClientRect().left}).left - svg.getBoundingClientRect().left;\r\n  let temp = node.cloneNode(true);\r\n  let head = temp.innerHTML.split('');\r\n  let tail = [];\r\n\r\n  // Insert temp off screen\r\n  temp.style.position = 'absolute';\r\n  temp.style.top = '-10000px';\r\n  temp.style.left = '-10000px';\r\n  document.body.appendChild(temp);\r\n\r\n  while (head.length) {\r\n    // Don't insert within HTML tags\r\n    if (head[head.length - 1] === '>') {\r\n      while (head.length) {\r\n        tail.unshift(head.pop());\r\n        if (tail[0] === '<') {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check if width of temp based on current head value satisfies x\r\n    temp.innerHTML = head.join('');\r\n    let width = Object(_UI_utils__WEBPACK_IMPORTED_MODULE_1__[\"scaleDown\"])(svg, {width: temp.getBoundingClientRect().width}).width;\r\n    if (left + width <= x) {\r\n      break;\r\n    }\r\n    tail.unshift(head.pop());\r\n  }\r\n\r\n  // Update original node with new markup, including element to be inserted\r\n  node.innerHTML = head.join('') + el.outerHTML + tail.join('');\r\n  temp.parentNode.removeChild(temp);\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Get a text layer element at a given point on a page\r\n *\r\n * @param {Number} x The x coordinate of the point\r\n * @param {Number} y The y coordinate of the point\r\n * @param {Number} pageNumber The page to limit elements to\r\n * @return {Element} First text layer element found at the point\r\n */\r\nfunction textLayerElementFromPoint(x, y, pageNumber) {\r\n  let svg = document.querySelector(`svg[data-pdf-annotate-page=\"${pageNumber}\"]`);\r\n  let rect = svg.getBoundingClientRect();\r\n  y = Object(_UI_utils__WEBPACK_IMPORTED_MODULE_1__[\"scaleUp\"])(svg, {y}).y + rect.top;\r\n  x = Object(_UI_utils__WEBPACK_IMPORTED_MODULE_1__[\"scaleUp\"])(svg, {x}).x + rect.left;\r\n  return [...svg.parentNode.querySelectorAll(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].textClassQuery() + ' [data-canvas-width]')].filter((el) => {\r\n    return Object(_UI_utils__WEBPACK_IMPORTED_MODULE_1__[\"pointIntersectsRect\"])(x, y, el.getBoundingClientRect());\r\n  })[0];\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/insertElementWithinElement.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderComment.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderComment.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return insertScreenReaderComment; });\n/**\r\n * Insert a comment into the DOM to be available by screen reader\r\n *\r\n * @param {Object} comment The comment to be inserted\r\n */\r\nfunction insertScreenReaderComment(comment) {\r\n  if (!comment) {\r\n    return;\r\n  }\r\n\r\n  let list = document.querySelector(`#pdf-annotate-screenreader-${comment.annotation} ol`);\r\n  if (list) {\r\n    let item = document.createElement('li');\r\n    item.setAttribute('id', `pdf-annotate-screenreader-comment-${comment.uuid}`);\r\n    item.appendChild(document.createTextNode(`${comment.content}`));\r\n    list.appendChild(item);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderComment.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderHint.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderHint.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return insertScreenReaderHint; });\n/* harmony import */ var _createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createScreenReaderOnly */ \"./node_modules/pdf-annotate.js/src/a11y/createScreenReaderOnly.js\");\n/* harmony import */ var _insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertElementWithinChildren */ \"./node_modules/pdf-annotate.js/src/a11y/insertElementWithinChildren.js\");\n/* harmony import */ var _insertElementWithinElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./insertElementWithinElement */ \"./node_modules/pdf-annotate.js/src/a11y/insertElementWithinElement.js\");\n/* harmony import */ var _renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderScreenReaderComments */ \"./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderComments.js\");\n\r\n\r\n\r\n\r\n\r\n// Annotation types that support comments\r\nconst COMMENT_TYPES = ['highlight', 'point', 'area', 'circle', 'emptycircle', 'fillcircle'];\r\n\r\n/**\r\n * Insert a hint into the DOM for screen readers for a specific annotation.\r\n *\r\n * @param {Object} annotation The annotation to insert a hint for\r\n * @param {Number} num The number of the annotation out of all annotations of the same type\r\n */\r\nfunction insertScreenReaderHint(annotation, num = 0) {\r\n  switch (annotation.type) {\r\n    case 'highlight':\r\n    case 'strikeout':\r\n      let rects = annotation.rectangles;\r\n      let first = rects[0];\r\n      let last = rects[rects.length - 1];\r\n\r\n      Object(_insertElementWithinElement__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\r\n        Object(_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(`Begin ${annotation.type} annotation ${num}`, annotation.uuid),\r\n        first.x, first.y, annotation.page, true\r\n      );\r\n\r\n      Object(_insertElementWithinElement__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\r\n        Object(_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(`End ${annotation.type} annotation ${num}`, `${annotation.uuid}-end`),\r\n        last.x + last.width, last.y, annotation.page, false\r\n      );\r\n      break;\r\n\r\n    case 'textbox':\r\n    case 'point':\r\n      let text = annotation.type === 'textbox' ? ` (content: ${annotation.content})` : '';\r\n\r\n      Object(_insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\r\n        Object(_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(`${annotation.type} annotation ${num}${text}`, annotation.uuid),\r\n        annotation.x, annotation.y, annotation.page\r\n      );\r\n      break;\r\n\r\n    case 'drawing':\r\n    case 'area':\r\n      let x = typeof annotation.x !== 'undefined' ? annotation.x : annotation.lines[0][0];\r\n      let y = typeof annotation.y !== 'undefined' ? annotation.y : annotation.lines[0][1];\r\n\r\n      Object(_insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\r\n        Object(_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(`Unlabeled drawing`, annotation.uuid),\r\n        x, y, annotation.page\r\n      );\r\n      break;\r\n\r\n    case 'circle':\r\n    case 'fillcircle':\r\n    case 'emptycircle':\r\n      let x2 = typeof annotation.cx !== 'undefined' ? annotation.cx : annotation.lines[0][0];\r\n      let y2 = typeof annotation.cy !== 'undefined' ? annotation.cy : annotation.lines[0][1];\r\n\r\n      Object(_insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\r\n        Object(_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(`Unlabeled drawing`, annotation.uuid),\r\n        x2, y2, annotation.page\r\n      );\r\n      break;\r\n  }\r\n\r\n  // Include comments in screen reader hint\r\n  if (COMMENT_TYPES.includes(annotation.type)) {\r\n    Object(_renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(annotation.documentId, annotation.uuid);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderHint.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderComments.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderComments.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderScreenReaderComments; });\n/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ \"./node_modules/pdf-annotate.js/src/PDFJSAnnotate.js\");\n/* harmony import */ var _insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertScreenReaderComment */ \"./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderComment.js\");\n\r\n\r\n\r\n/**\r\n * Insert the comments into the DOM to be available by screen reader\r\n *\r\n * Example output:\r\n *   <div class=\"screenReaderOnly\">\r\n *    <div>Begin highlight 1</div>\r\n *    <ol aria-label=\"Comments\">\r\n *      <li>Foo</li>\r\n *      <li>Bar</li>\r\n *      <li>Baz</li>\r\n *      <li>Qux</li>\r\n *    </ol>\r\n *  </div>\r\n *  <div>Some highlighted text goes here...</div>\r\n *  <div class=\"screenReaderOnly\">End highlight 1</div>\r\n *\r\n * NOTE: `screenReaderOnly` is not a real class, just used for brevity\r\n *\r\n * @param {String} documentId The ID of the document\r\n * @param {String} annotationId The ID of the annotation\r\n * @param {Array} [comments] Optionally preloaded comments to be rendered\r\n * @return {Promise} Promise that once has comments, render them for screen reader\r\n */\r\nfunction renderScreenReaderComments(documentId, annotationId, comments) {\r\n  let promise;\r\n\r\n  if (Array.isArray(comments)) {\r\n    promise = Promise.resolve(comments);\r\n  }\r\n  else {\r\n    promise = _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().getComments(documentId, annotationId);\r\n  }\r\n\r\n  return promise.then((comments) => {\r\n    // Node needs to be found by querying DOM as it may have been inserted as innerHTML\r\n    // leaving `screenReaderNode` as an invalid reference (see `insertElementWithinElement`).\r\n    let node = document.getElementById(`pdf-annotate-screenreader-${annotationId}`);\r\n    if (node) {\r\n      let list = document.createElement('ol');\r\n      list.setAttribute('id', `pdf-annotate-screenreader-comment-list-${annotationId}`);\r\n      list.setAttribute('aria-label', 'Comments');\r\n      node.appendChild(list);\r\n      comments.forEach(_insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\r\n    }\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderComments.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderHints.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderHints.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderScreenReaderHints; });\n/* harmony import */ var _insertScreenReaderHint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./insertScreenReaderHint */ \"./node_modules/pdf-annotate.js/src/a11y/insertScreenReaderHint.js\");\n/* harmony import */ var _initEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./initEventHandlers */ \"./node_modules/pdf-annotate.js/src/a11y/initEventHandlers.js\");\n\r\n\r\n\r\n// TODO This is not the right place for this to live\r\nObject(_initEventHandlers__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\n\r\n/**\r\n * Insert hints into the DOM for screen readers.\r\n *\r\n * @param {Array} annotations The annotations that hints are inserted for\r\n */\r\nfunction renderScreenReaderHints(annotations) {\r\n  annotations = Array.isArray(annotations) ? annotations : [];\r\n\r\n  // Insert hints for each type\r\n  Object.keys(SORT_TYPES).forEach((type) => {\r\n    let sortBy = SORT_TYPES[type];\r\n    annotations\r\n      .filter((a) => a.type === type)\r\n      .sort(sortBy)\r\n      .forEach((a, i) => Object(_insertScreenReaderHint__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(a, i + 1));\r\n  });\r\n}\r\n\r\n// Sort annotations first by y, then by x.\r\n// This allows hints to be injected in the order they appear,\r\n// which makes numbering them easier.\r\nfunction sortByPoint(a, b) {\r\n  if (a.y < b.y) {\r\n    return a.x - b.x;\r\n  }\r\n  else {\r\n    return 1;\r\n  }\r\n}\r\n\r\n// Sort annotation by it's first rectangle\r\nfunction sortByRectPoint(a, b) {\r\n  return sortByPoint(a.rectangles[0], b.rectangles[0]);\r\n}\r\n\r\n// Sort annotation by it's first line\r\nfunction sortByLinePoint(a, b) {\r\n  let lineA = a.lines[0];\r\n  let lineB = b.lines[0];\r\n  return sortByPoint(\r\n    {x: lineA[0], y: lineA[1]},\r\n    {x: lineB[0], y: lineB[1]}\r\n  );\r\n}\r\n\r\n// Arrange supported types and associated sort methods\r\nconst SORT_TYPES = {\r\n  'highlight': sortByRectPoint,\r\n  'strikeout': sortByRectPoint,\r\n  'drawing': sortByLinePoint,\r\n  'textbox': sortByPoint,\r\n  'point': sortByPoint,\r\n  'area': sortByPoint\r\n};\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/a11y/renderScreenReaderHints.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/adapter/LocalStoreAdapter.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/adapter/LocalStoreAdapter.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LocalStoreAdapter; });\n/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/uuid */ \"./node_modules/pdf-annotate.js/src/utils/uuid.js\");\n/* harmony import */ var _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StoreAdapter */ \"./node_modules/pdf-annotate.js/src/adapter/StoreAdapter.js\");\n\r\n\r\n\r\n// StoreAdapter for working with localStorage\r\n// This is ideal for testing, examples, and prototyping\r\nclass LocalStoreAdapter extends _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor() {\r\n    super({\r\n      getAnnotations(documentId, pageNumber) {\r\n        return new Promise((resolve, reject) => {\r\n          let annotations = getAnnotations(documentId).filter((i) => {\r\n            return i.page === pageNumber && i.class === 'Annotation';\r\n          });\r\n\r\n          resolve({\r\n            documentId,\r\n            pageNumber,\r\n            annotations\r\n          });\r\n        });\r\n      }\r\n    });\r\n\r\n    this.getAnnotation = (documentId, annotationId) => {\r\n      return Promise.resolve(getAnnotations(documentId)[findAnnotation(documentId, annotationId)]);\r\n    };\r\n\r\n    this.addAnnotation = (documentId, pageNumber, annotation) => {\r\n      return new Promise((resolve, reject) => {\r\n        annotation.class = 'Annotation';\r\n        annotation.uuid = Object(_utils_uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n        annotation.page = pageNumber;\r\n\r\n        let annotations = getAnnotations(documentId);\r\n        annotations.push(annotation);\r\n        updateAnnotations(documentId, annotations);\r\n\r\n        resolve(annotation);\r\n      });\r\n    };\r\n\r\n    this.editAnnotation = (documentId, annotationId, annotation) => {\r\n      return new Promise((resolve, reject) => {\r\n        let annotations = getAnnotations(documentId);\r\n        annotations[findAnnotation(documentId, annotationId)] = annotation;\r\n        updateAnnotations(documentId, annotations);\r\n        resolve(annotation);\r\n      });\r\n    };\r\n\r\n    this.deleteAnnotation = (documentId, annotationId) => {\r\n      return new Promise((resolve, reject) => {\r\n        let annotation = getAnnotations(documentId).filter(i => i.uuid === annotationId)[0] || {};\r\n        if (!annotation) {\r\n          return reject('Could not find annotation');\r\n        }\r\n        let index = findAnnotation(documentId, annotationId);\r\n        if (index > -1) {\r\n          let annotations = getAnnotations(documentId);\r\n          annotations.splice(index, 1);\r\n          updateAnnotations(documentId, annotations);\r\n        }\r\n\r\n        resolve(true);\r\n      });\r\n    };\r\n\r\n    this.getComments = (documentId, annotationId) => {\r\n      return new Promise((resolve, reject) => {\r\n        resolve(getAnnotations(documentId).filter((i) => {\r\n          return i.class === 'Comment' && i.annotation === annotationId;\r\n        }));\r\n      });\r\n    };\r\n\r\n    this.addComment = (documentId, annotationId, content) => {\r\n      return new Promise((resolve, reject) => {\r\n        let comment = {\r\n          class: 'Comment',\r\n          uuid: Object(_utils_uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\r\n          annotation: annotationId,\r\n          content: content\r\n        };\r\n\r\n        let annotations = getAnnotations(documentId);\r\n        annotations.push(comment);\r\n        updateAnnotations(documentId, annotations);\r\n\r\n        resolve(comment);\r\n      });\r\n    };\r\n\r\n    this.deleteComment = (documentId, commentId) => {\r\n      return new Promise((resolve, reject) => {\r\n        let comment = getAnnotations(documentId).filter(i => i.uuid === commentId)[0] || {};\r\n        if (!comment) {\r\n          return reject('Could not find annotation');\r\n        }\r\n        let index = -1;\r\n        let annotations = getAnnotations(documentId);\r\n        for (let i = 0, l = annotations.length; i < l; i++) {\r\n          if (annotations[i].uuid === commentId) {\r\n            index = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (index > -1) {\r\n          annotations.splice(index, 1);\r\n          updateAnnotations(documentId, annotations);\r\n        }\r\n\r\n        resolve(true);\r\n      });\r\n    };\r\n  }\r\n}\r\n\r\nfunction getAnnotations(documentId) {\r\n  return JSON.parse(localStorage.getItem(`${documentId}/annotations`)) || [];\r\n}\r\n\r\nfunction updateAnnotations(documentId, annotations) {\r\n  localStorage.setItem(`${documentId}/annotations`, JSON.stringify(annotations));\r\n}\r\n/**\r\n *\r\n * @param {String} documentId Document id of the annotation\r\n * @param {String} annotationId The id of the annotation\r\n *\r\n * This function finds all the annotation made by one user.\r\n *\r\n * @return {int} The index of the annotation in localstorage\r\n */\r\nfunction findAnnotation(documentId, annotationId) {\r\n  let index = -1;\r\n  let annotations = getAnnotations(documentId);\r\n  for (let i = 0, l = annotations.length; i < l; i++) {\r\n    if (annotations[i].uuid === annotationId) {\r\n      index = i;\r\n      break;\r\n    }\r\n  }\r\n  return index;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/adapter/LocalStoreAdapter.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/adapter/LocalUserStoreAdapter.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/adapter/LocalUserStoreAdapter.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LocalUserStoreAdapter; });\n/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/uuid */ \"./node_modules/pdf-annotate.js/src/utils/uuid.js\");\n/* harmony import */ var _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StoreAdapter */ \"./node_modules/pdf-annotate.js/src/adapter/StoreAdapter.js\");\n\r\n\r\n\r\n// StoreAdapter for working with localStorage and associated user id\r\n// This is ideal for testing, examples, and prototyping\r\nclass LocalUserStoreAdapter extends _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  constructor(userId = 'user', globalEdit = false) {\r\n    super({\r\n      getAnnotations(documentId, pageNumber) {\r\n        return new Promise((resolve, reject) => {\r\n          let annotations = getAllAnnotations(documentId).filter((i) => {\r\n            return i.page === pageNumber && i.class === 'Annotation';\r\n          });\r\n\r\n          resolve({\r\n            documentId,\r\n            pageNumber,\r\n            annotations\r\n          });\r\n        });\r\n      }\r\n    });\r\n\r\n    this._userId = userId;\r\n    this._globalEdit = globalEdit;\r\n\r\n    this.getAnnotation = (documentId, annotationId) => {\r\n      return Promise.resolve(getAnnotations(documentId, this._userId)[findAnnotation(documentId, this._userId, annotationId)]);\r\n    };\r\n\r\n    this.addAnnotation = (documentId, pageNumber, annotation) => {\r\n      return new Promise((resolve, reject) => {\r\n        annotation.class = 'Annotation';\r\n        annotation.uuid = Object(_utils_uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n        annotation.page = pageNumber;\r\n        annotation.userId = this._userId;\r\n\r\n        let annotations = getAnnotations(documentId, this._userId);\r\n        annotations.push(annotation);\r\n        updateAnnotations(documentId, this._userId, annotations);\r\n\r\n        resolve(annotation);\r\n      });\r\n    };\r\n\r\n    this.editAnnotation = (documentId, annotationId, annotation) => {\r\n      return new Promise((resolve, reject) => {\r\n        if (!this._globalEdit && annotation.userId && annotation.userId !== this._userId) {\r\n          reject('Non-matching userId');\r\n        }\r\n        let annotations = getAnnotations(documentId, annotation.userId);\r\n        annotations[findAnnotation(documentId, annotation.userId, annotationId)] = annotation;\r\n        updateAnnotations(documentId, annotation.userId, annotations);\r\n        resolve(annotation);\r\n      });\r\n    };\r\n\r\n    this.deleteAnnotation = (documentId, annotationId) => {\r\n      return new Promise((resolve, reject) => {\r\n        let annotation = getAllAnnotations(documentId).filter(i => i.uuid === annotationId)[0] || {};\r\n        if (!annotation) {\r\n          return reject('Could not find annotation');\r\n        }\r\n        else if (!this._globalEdit && annotation.userId && annotation.userId !== this._userId) {\r\n          return reject('Non-matching userId');\r\n        }\r\n        let index = findAnnotation(documentId, annotation.userId, annotationId);\r\n        if (index > -1) {\r\n          let annotations = getAnnotations(documentId, annotation.userId);\r\n          annotations.splice(index, 1);\r\n          updateAnnotations(documentId, annotation.userId, annotations);\r\n        }\r\n\r\n        resolve(true);\r\n      });\r\n    };\r\n\r\n    this.getComments = (documentId, annotationId) => {\r\n      return new Promise((resolve, reject) => {\r\n        resolve(getAnnotations(documentId, this._userId).filter((i) => {\r\n          return i.class === 'Comment' && i.annotation === annotationId;\r\n        }));\r\n      });\r\n    };\r\n\r\n    this.addComment = (documentId, annotationId, content) => {\r\n      return new Promise((resolve, reject) => {\r\n        let comment = {\r\n          class: 'Comment',\r\n          uuid: Object(_utils_uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\r\n          annotation: annotationId,\r\n          content: content,\r\n          userId: this._userId\r\n        };\r\n\r\n        let annotations = getAnnotations(documentId, this._userId);\r\n        annotations.push(comment);\r\n        updateAnnotations(documentId, this._userId, annotations);\r\n\r\n        resolve(comment);\r\n      });\r\n    };\r\n\r\n    this.deleteComment = (documentId, commentId) => {\r\n      return new Promise((resolve, reject) => {\r\n        let comment = getAllAnnotations(documentId).filter(i => i.uuid === commentId)[0] || {};\r\n        if (!comment) {\r\n          return reject('Could not find annotation');\r\n        }\r\n        else if (!this._globalEdit && comment.userId && comment.userId !== this._userId) {\r\n          return reject('Non-matching userId');\r\n        }\r\n        let index = -1;\r\n        let annotations = getAnnotations(documentId, comment.userId);\r\n        for (let i = 0, l = annotations.length; i < l; i++) {\r\n          if (annotations[i].uuid === commentId) {\r\n            index = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (index > -1) {\r\n          annotations.splice(index, 1);\r\n          updateAnnotations(documentId, comment.userId, annotations);\r\n        }\r\n\r\n        resolve(true);\r\n      });\r\n    };\r\n  }\r\n\r\n  get userId() {\r\n    return this._userId;\r\n  }\r\n}\r\n\r\nfunction getAllAnnotations(documentId) {\r\n  let all_annotations = [];\r\n  let re = new RegExp(`${documentId}/(.*)/annotations`);\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    if (localStorage.key(i).search(re) > -1) {\r\n      all_annotations.push(...JSON.parse(localStorage.getItem(localStorage.key(i))));\r\n    }\r\n  }\r\n  return all_annotations;\r\n}\r\n\r\nfunction getAnnotations(documentId, userId) {\r\n  return JSON.parse(localStorage.getItem(`${documentId}/${userId}/annotations`)) || [];\r\n}\r\n\r\nfunction updateAnnotations(documentId, userId, annotations) {\r\n  localStorage.setItem(`${documentId}/${userId}/annotations`, JSON.stringify(annotations));\r\n}\r\n/**\r\n *\r\n * @param {String} documentId Document id of the annotation\r\n * @param {String} userId User id of the annotation\r\n * @param {String} annotationId The id of the annotation\r\n *\r\n * This function finds all the annotation made by one user.\r\n *\r\n * @return {int} The index of the annotation in localstorage\r\n */\r\nfunction findAnnotation(documentId, userId, annotationId) {\r\n  let index = -1;\r\n  let annotations = getAnnotations(documentId, userId);\r\n  for (let i = 0, l = annotations.length; i < l; i++) {\r\n    if (annotations[i].uuid === annotationId) {\r\n      index = i;\r\n      break;\r\n    }\r\n  }\r\n  return index;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/adapter/LocalUserStoreAdapter.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/adapter/StoreAdapter.js":
/*!******************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/adapter/StoreAdapter.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StoreAdapter; });\n/* harmony import */ var _utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/abstractFunction */ \"./node_modules/pdf-annotate.js/src/utils/abstractFunction.js\");\n/* harmony import */ var _UI_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/event */ \"./node_modules/pdf-annotate.js/src/UI/event.js\");\n// Disable JSDoc as it cannot really deal with the odd way that the functions are defined\r\n/* eslint valid-jsdoc: 0 */\r\n\r\n\r\n\r\n\r\n// Adapter should never be invoked publicly\r\nclass StoreAdapter {\r\n  /**\r\n   * Create a new StoreAdapter instance\r\n   *\r\n   * @param {Object} [definition] The definition to use for overriding abstract methods\r\n   */\r\n  constructor(definition = {}) {\r\n    // Copy each function from definition if it is a function we know about\r\n    Object.keys(definition).forEach((key) => {\r\n      if (typeof definition[key] === 'function' &&\r\n          typeof this[key] === 'function') {\r\n        this[key] = definition[key];\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get all the annotations for a given document and page number.\r\n   *\r\n   * @param {String} documentId The ID for the document the annotations belong to\r\n   * @param {Number} pageNumber The number of the page the annotations belong to\r\n   * @return {Promise} Promise that returns with list of annotations for document and page\r\n   */\r\n  __getAnnotations(documentId, pageNumber) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('getAnnotations'); }\r\n  get getAnnotations() { return this.__getAnnotations; }\r\n  set getAnnotations(fn) {\r\n    this.__getAnnotations = function getAnnotations(documentId, pageNumber) {\r\n      return fn(...arguments).then((annotations) => {\r\n        // TODO may be best to have this happen on the server\r\n        if (annotations.annotations) {\r\n          annotations.annotations.forEach((a) => {\r\n            a.documentId = documentId;\r\n          });\r\n        }\r\n        return annotations;\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the definition for a specific annotation.\r\n   *\r\n   * @param {String} documentId The ID for the document the annotation belongs to\r\n   * @param {String} annotationId The ID for the annotation\r\n   * @return {Promise} Promise that returns the requested annotation\r\n   */\r\n  getAnnotation(documentId, annotationId) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('getAnnotation'); }\r\n\r\n  /**\r\n   * Add an annotation\r\n   *\r\n   * @param {String} documentId The ID for the document to add the annotation to\r\n   * @param {String} pageNumber The page number to add the annotation to\r\n   * @param {Object} annotation The definition for the new annotation\r\n   * @return {Promise} Promise that returns with the added annotation\r\n   */\r\n  __addAnnotation(documentId, pageNumber, annotation) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('addAnnotation'); }\r\n  get addAnnotation() { return this.__addAnnotation; }\r\n  set addAnnotation(fn) {\r\n    this.__addAnnotation = function addAnnotation(documentId, pageNumber, annotation) {\r\n      return fn(...arguments).then((annotation) => {\r\n        Object(_UI_event__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])('annotation:add', documentId, pageNumber, annotation);\r\n        return annotation;\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Edit an annotation\r\n   *\r\n   * @param {String} documentId The ID for the document\r\n   * @param {String} pageNumber the page number of the annotation\r\n   * @param {Object} annotation The definition of the modified annotation\r\n   * @return {Promise} Promise that returns with the edited annotation\r\n   */\r\n  __editAnnotation(documentId, pageNumber, annotation) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('editAnnotation'); }\r\n  get editAnnotation() { return this.__editAnnotation; }\r\n  set editAnnotation(fn) {\r\n    this.__editAnnotation = function editAnnotation(documentId, annotationId, annotation) {\r\n      return fn(...arguments).then((annotation) => {\r\n        Object(_UI_event__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])('annotation:edit', documentId, annotationId, annotation);\r\n        return annotation;\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Delete an annotation\r\n   *\r\n   * @param {String} documentId The ID for the document\r\n   * @param {String} annotationId The ID for the annotation\r\n   * @return {Promise} Promise that returns with boolean if annotation was deleted\r\n   */\r\n  __deleteAnnotation(documentId, annotationId) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('deleteAnnotation'); }\r\n  get deleteAnnotation() { return this.__deleteAnnotation; }\r\n  set deleteAnnotation(fn) {\r\n    this.__deleteAnnotation = function deleteAnnotation(documentId, annotationId) {\r\n      return fn(...arguments).then((success) => {\r\n        if (success) {\r\n          Object(_UI_event__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])('annotation:delete', documentId, annotationId);\r\n        }\r\n        return success;\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all the comments for an annotation\r\n   *\r\n   * @param {String} documentId The ID for the document\r\n   * @param {String} annotationId The ID for the annotation\r\n   * @return {Promise} Promise that returns with comments for annotation\r\n   */\r\n  getComments(documentId, annotationId) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('getComments'); }\r\n\r\n  /**\r\n   * Add a new comment\r\n   *\r\n   * @param {String} documentId The ID for the document\r\n   * @param {String} annotationId The ID for the annotation\r\n   * @param {Object} content The definition of the comment\r\n   * @return {Promise} Promise that returns with the added comment\r\n   */\r\n  __addComment(documentId, annotationId, content) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('addComment'); }\r\n  get addComment() { return this.__addComment; }\r\n  set addComment(fn) {\r\n    this.__addComment = function addComment(documentId, annotationId, content) {\r\n      return fn(...arguments).then((comment) => {\r\n        Object(_UI_event__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])('comment:add', documentId, annotationId, comment);\r\n        return comment;\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Delete a comment\r\n   *\r\n   * @param {String} documentId The ID for the document\r\n   * @param {String} commentId The ID for the comment\r\n   * @return {Promise} Promise that returns with boolean if comment was deleted\r\n   */\r\n  __deleteComment(documentId, commentId) { Object(_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('deleteComment'); }\r\n  get deleteComment() { return this.__deleteComment; }\r\n  set deleteComment(fn) {\r\n    this.__deleteComment = function deleteComment(documentId, commentId) {\r\n      return fn(...arguments).then((success) => {\r\n        if (success) {\r\n          Object(_UI_event__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])('comment:delete', documentId, commentId);\r\n        }\r\n        return success;\r\n      });\r\n    };\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/adapter/StoreAdapter.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/config.js":
/*!****************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/config.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  annotationLayerName: 'annotationLayer',\r\n  textLayerName: 'textLayer',\r\n  annotationSvgQuery: function() {\r\n    return 'svg.' + this.annotationLayerName;\r\n  },\r\n  annotationClassQuery: function() {\r\n    return '.' + this.annotationLayerName;\r\n  },\r\n  textClassQuery: function() {\r\n    return '.' + this.textLayerName;\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/config.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/appendChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/appendChild.js ***!
  \****************************************************************/
/*! exports provided: getTranslation, appendChild, transformChild, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"appendChild\", function() { return appendChild; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformChild\", function() { return transformChild; });\n/* harmony import */ var _renderLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderLine */ \"./node_modules/pdf-annotate.js/src/render/renderLine.js\");\n/* harmony import */ var _renderPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderPath */ \"./node_modules/pdf-annotate.js/src/render/renderPath.js\");\n/* harmony import */ var _renderPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderPoint */ \"./node_modules/pdf-annotate.js/src/render/renderPoint.js\");\n/* harmony import */ var _renderRect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderRect */ \"./node_modules/pdf-annotate.js/src/render/renderRect.js\");\n/* harmony import */ var _renderText__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderText */ \"./node_modules/pdf-annotate.js/src/render/renderText.js\");\n/* harmony import */ var _renderCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderCircle */ \"./node_modules/pdf-annotate.js/src/render/renderCircle.js\");\n/* harmony import */ var _renderArrow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderArrow */ \"./node_modules/pdf-annotate.js/src/render/renderArrow.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst isFirefox = /firefox/i.test(navigator.userAgent);\r\n\r\n/**\r\n * Get the x/y translation to be used for transforming the annotations\r\n * based on the rotation of the viewport.\r\n *\r\n * @param {Object} viewport The viewport data from the page\r\n * @return {Object}\r\n */\r\nfunction getTranslation(viewport) {\r\n  let x;\r\n  let y;\r\n\r\n  // Modulus 360 on the rotation so that we only\r\n  // have to worry about four possible values.\r\n  switch (viewport.rotation % 360) {\r\n    case 0:\r\n      x = y = 0;\r\n      break;\r\n    case 90:\r\n      x = 0;\r\n      y = (viewport.width / viewport.scale) * -1;\r\n      break;\r\n    case 180:\r\n      x = (viewport.width / viewport.scale) * -1;\r\n      y = (viewport.height / viewport.scale) * -1;\r\n      break;\r\n    case 270:\r\n      x = (viewport.height / viewport.scale) * -1;\r\n      y = 0;\r\n      break;\r\n  }\r\n\r\n  return { x, y };\r\n}\r\n\r\n/**\r\n * Transform the rotation and scale of a node using SVG's native transform attribute.\r\n *\r\n * @param {Node} node The node to be transformed\r\n * @param {Object} viewport The page's viewport data\r\n * @return {Node}\r\n */\r\nfunction transform(node, viewport) {\r\n  let trans = getTranslation(viewport);\r\n\r\n  // Let SVG natively transform the element\r\n  node.setAttribute('transform', `scale(${viewport.scale}) rotate(${viewport.rotation}) translate(${trans.x}, ${trans.y})`);\r\n\r\n  // Manually adjust x/y for nested SVG nodes\r\n  if (!isFirefox && node.nodeName.toLowerCase() === 'svg') {\r\n    node.setAttribute('x', parseInt(node.getAttribute('x'), 10) * viewport.scale);\r\n    node.setAttribute('y', parseInt(node.getAttribute('y'), 10) * viewport.scale);\r\n\r\n    let x = parseInt(node.getAttribute('x', 10));\r\n    let y = parseInt(node.getAttribute('y', 10));\r\n    let width = parseInt(node.getAttribute('width'), 10);\r\n    let height = parseInt(node.getAttribute('height'), 10);\r\n    let path = node.querySelector('path');\r\n    let svg = path.parentNode;\r\n\r\n    // Scale width/height\r\n    [node, svg, path, node.querySelector('rect')].forEach((n) => {\r\n      n.setAttribute('width', parseInt(n.getAttribute('width'), 10) * viewport.scale);\r\n      n.setAttribute('height', parseInt(n.getAttribute('height'), 10) * viewport.scale);\r\n    });\r\n\r\n    // Transform path but keep scale at 100% since it will be handled natively\r\n    transform(path, Object.assign({}, viewport, { scale: 1 }));\r\n\r\n    switch (viewport.rotation % 360) {\r\n      case 90:\r\n        node.setAttribute('x', viewport.width - y - width);\r\n        node.setAttribute('y', x);\r\n        svg.setAttribute('x', 1);\r\n        svg.setAttribute('y', 0);\r\n        break;\r\n      case 180:\r\n        node.setAttribute('x', viewport.width - x - width);\r\n        node.setAttribute('y', viewport.height - y - height);\r\n        svg.setAttribute('y', 2);\r\n        break;\r\n      case 270:\r\n        node.setAttribute('x', y);\r\n        node.setAttribute('y', viewport.height - x - height);\r\n        svg.setAttribute('x', -1);\r\n        svg.setAttribute('y', 0);\r\n        break;\r\n    }\r\n  }\r\n\r\n  return node;\r\n}\r\n\r\n/**\r\n * Append an annotation as a child of an SVG.\r\n *\r\n * @param {SVGElement} svg The SVG element to append the annotation to\r\n * @param {Object} annotation The annotation definition to render and append\r\n * @param {Object} viewport The page's viewport data\r\n * @return {SVGElement} A node that was created and appended by this function\r\n */\r\nfunction appendChild(svg, annotation, viewport) {\r\n  if (!viewport) {\r\n    viewport = JSON.parse(svg.getAttribute('data-pdf-annotate-viewport'));\r\n  }\r\n\r\n  let child;\r\n  switch (annotation.type) {\r\n    case 'area':\r\n    case 'highlight':\r\n      child = Object(_renderRect__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(annotation);\r\n      break;\r\n    case 'circle':\r\n    case 'fillcircle':\r\n    case 'emptycircle':\r\n      child = Object(_renderCircle__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(annotation);\r\n      break;\r\n    case 'strikeout':\r\n      child = Object(_renderLine__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(annotation);\r\n      break;\r\n    case 'point':\r\n      child = Object(_renderPoint__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(annotation);\r\n      break;\r\n    case 'textbox':\r\n      child = Object(_renderText__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(annotation);\r\n      break;\r\n    case 'drawing':\r\n      child = Object(_renderPath__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(annotation);\r\n      break;\r\n    case 'arrow':\r\n      child = Object(_renderArrow__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(annotation);\r\n      break;\r\n  }\r\n\r\n  // If no type was provided for an annotation it will result in node being null.\r\n  // Skip appending/transforming if node doesn't exist.\r\n  if (child) {\r\n    // Set attributes\r\n    child.setAttribute('data-pdf-annotate-id', annotation.uuid);\r\n    child.setAttribute('aria-hidden', true);\r\n\r\n    // Dynamically set any other attributes associated with annotation that is not related to drawing it\r\n    Object.keys(annotation).filter((key) => {\r\n      return ['color', 'x', 'y', 'cx', 'cy', 'color', 'documentId', 'lines', 'page',\r\n        'width', 'class', 'content', 'size', 'rotation', 'r'].indexOf(key) === -1;\r\n    }).forEach((key) => {\r\n      child.setAttribute(`data-pdf-annotate-${key}`, annotation[key]);\r\n    });\r\n\r\n    svg.appendChild(transform(child, viewport));\r\n  }\r\n\r\n  return child;\r\n}\r\n\r\n/**\r\n * Transform a child annotation of an SVG.\r\n *\r\n * @param {SVGElement} svg The SVG element with the child annotation\r\n * @param {Object} child The SVG child to transform\r\n * @param {Object} viewport The page's viewport data\r\n * @return {SVGElement} A node that was transformed by this function\r\n */\r\nfunction transformChild(svg, child, viewport) {\r\n  if (!viewport) {\r\n    viewport = JSON.parse(svg.getAttribute('data-pdf-annotate-viewport'));\r\n  }\r\n\r\n  // If no type was provided for an annotation it will result in node being null.\r\n  // Skip transforming if node doesn't exist.\r\n  if (child) {\r\n    child = transform(child, viewport);\r\n  }\r\n\r\n  return child;\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  /**\r\n   * Get the x/y translation to be used for transforming the annotations\r\n   * based on the rotation of the viewport.\r\n   */\r\n  getTranslation,\r\n\r\n  /**\r\n   * Append an SVG child for an annotation\r\n   */\r\n  appendChild,\r\n\r\n  /**\r\n   * Transform an existing SVG child\r\n   */\r\n  transformChild\r\n});\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/appendChild.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/index.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return render; });\n/* harmony import */ var _appendChild__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appendChild */ \"./node_modules/pdf-annotate.js/src/render/appendChild.js\");\n\r\n\r\n/**\r\n * Render the response from PDFJSAnnotate.getStoreAdapter().getAnnotations to SVG\r\n *\r\n * @param {SVGElement} svg The SVG element to render the annotations to\r\n * @param {Object} viewport The page viewport data\r\n * @param {Object} data The response from PDFJSAnnotate.getStoreAdapter().getAnnotations\r\n * @return {Promise} Settled once rendering has completed\r\n *  A settled Promise will be either:\r\n *    - fulfilled: SVGElement\r\n *    - rejected: Error\r\n */\r\nfunction render(svg, viewport, data) {\r\n  return new Promise((resolve, reject) => {\r\n    // Reset the content of the SVG\r\n    svg.setAttribute('data-pdf-annotate-container', true);\r\n    svg.setAttribute('data-pdf-annotate-viewport', JSON.stringify(viewport));\r\n    svg.removeAttribute('data-pdf-annotate-document');\r\n    svg.removeAttribute('data-pdf-annotate-page');\r\n\r\n    // If there's no data nothing can be done\r\n    if (!data) {\r\n      svg.innerHTML = '';\r\n      return resolve(svg);\r\n    }\r\n\r\n    svg.setAttribute('data-pdf-annotate-document', data.documentId);\r\n    svg.setAttribute('data-pdf-annotate-page', data.pageNumber);\r\n\r\n    // Make sure annotations is an array\r\n    if (!Array.isArray(data.annotations) || data.annotations.length === 0) {\r\n      return resolve(svg);\r\n    }\r\n\r\n    // Append or transform annotation to svg\r\n    data.annotations.forEach((a) => {\r\n      let node = svg.querySelector('[data-pdf-annotate-id=\"' + a.uuid + '\"]');\r\n      if (node) {\r\n        Object(_appendChild__WEBPACK_IMPORTED_MODULE_0__[\"transformChild\"])(svg, node, viewport);\r\n      }\r\n      else {\r\n        Object(_appendChild__WEBPACK_IMPORTED_MODULE_0__[\"appendChild\"])(svg, a, viewport);\r\n      }\r\n    });\r\n\r\n    resolve(svg);\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/index.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderArrow.js":
/*!****************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderArrow.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderArrow; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ \"./node_modules/pdf-annotate.js/src/utils/normalizeColor.js\");\n/* harmony import */ var _utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mathUtils */ \"./node_modules/pdf-annotate.js/src/utils/mathUtils.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Create SVGPathElement from an annotation definition.\r\n * This is used for anntations of type `drawing`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGPathElement} The path to be rendered\r\n */\r\nfunction renderArrow(a) {\r\n  let arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\r\n\r\n  if (a.lines.length === 2) {\r\n    let p1 = a.lines[0];\r\n    let p2 = a.lines[a.lines.length - 1];\r\n\r\n    let arrowLength = 40;\r\n    let pt0 = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"makePoint\"])(p1[0], p1[1], 0);\r\n    let pt1 = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"makePoint\"])(p2[0], p2[1], 0);\r\n    let x = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"makeVectorFromPoints\"])(pt0, pt1);\r\n    let unitX = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"unitVector\"])(x);\r\n    pt1 = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(pt0, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(unitX, arrowLength));\r\n    x = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"makeVectorFromPoints\"])(pt0, pt1);\r\n    let unitZ = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"makeVector\"])(0, 0, 1);\r\n    let unitY = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"unitVector\"])(Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"crossProduct\"])(unitX, unitZ));\r\n    let thickness = a.width || 10;\r\n\r\n    let A = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(pt0, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(unitY, thickness * 0.5));\r\n    let B = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(A, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(unitX, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"magnitude\"])(x) - thickness * 2.0));\r\n    let C = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(B, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(unitY, thickness));\r\n    let D = pt1;\r\n    let G = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(pt0, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"negateVector\"])(unitY), thickness * 0.5));\r\n    let F = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(G, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(unitX, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"magnitude\"])(x) - thickness * 2.0));\r\n    let E = Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"addVector\"])(F, Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"multiplyVector\"])(Object(_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__[\"negateVector\"])(unitY), thickness));\r\n\r\n    let points = '' +\r\n      A.x + ',' + A.y + ' ' +\r\n      B.x + ',' + B.y + ' ' +\r\n      C.x + ',' + C.y + ' ' +\r\n      D.x + ',' + D.y + ' ' +\r\n      E.x + ',' + E.y + ' ' +\r\n      F.x + ',' + F.y + ' ' +\r\n      G.x + ',' + G.y;\r\n\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arrow, {\r\n      points: points,\r\n      stroke: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#000'),\r\n      fill: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#000')\r\n    });\r\n  }\r\n\r\n  return arrow;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderArrow.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderCircle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderCircle.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderCircle; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ \"./node_modules/pdf-annotate.js/src/utils/normalizeColor.js\");\n\r\n\r\n\r\n/**\r\n * Create an SVGCircleElement from an annotation definition.\r\n * This is used for annotations of type `circle`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGGElement|SVGCircleElement} A circle to be rendered\r\n */\r\nfunction renderCircle(a) {\r\n  let circle = createCircle(a);\r\n  let color = Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#f00');\r\n\r\n  if (a.type === 'circle') {\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(circle, {\r\n      stroke: color,\r\n      fill: 'none',\r\n      'stroke-width': 5\r\n    });\r\n  }\r\n  if (a.type === 'emptycircle') {\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(circle, {\r\n      stroke: color,\r\n      fill: 'none',\r\n      'stroke-width': 2\r\n    });\r\n  }\r\n\r\n  if (a.type === 'fillcircle') {\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(circle, {\r\n      stroke: color,\r\n      fill: color,\r\n      'stroke-width': 5\r\n    });\r\n  }\r\n\r\n  return circle;\r\n}\r\n\r\nfunction createCircle(a) {\r\n  let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(circle, {\r\n    cx: a.cx,\r\n    cy: a.cy,\r\n    r: a.r\r\n  });\r\n\r\n  return circle;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderCircle.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderLine.js":
/*!***************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderLine.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderLine; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ \"./node_modules/pdf-annotate.js/src/utils/normalizeColor.js\");\n\r\n\r\n\r\n/**\r\n * Create SVGLineElements from an annotation definition.\r\n * This is used for anntations of type `strikeout`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGGElement} A group of all lines to be rendered\r\n */\r\nfunction renderLine(a) {\r\n  let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(group, {\r\n    stroke: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#f00'),\r\n    strokeWidth: 1\r\n  });\r\n\r\n  a.rectangles.forEach((r) => {\r\n    let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\r\n\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(line, {\r\n      x1: r.x,\r\n      y1: r.y,\r\n      x2: r.x + r.width,\r\n      y2: r.y\r\n    });\r\n\r\n    group.appendChild(line);\r\n  });\r\n\r\n  return group;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderLine.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderPath.js":
/*!***************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderPath.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderPath; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ \"./node_modules/pdf-annotate.js/src/utils/normalizeColor.js\");\n\r\n\r\n\r\n/**\r\n * Create SVGPathElement from an annotation definition.\r\n * This is used for anntations of type `drawing`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGPathElement} The path to be rendered\r\n */\r\nfunction renderPath(a) {\r\n  let d = [];\r\n  let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n\r\n  if (a.lines.length > 0) {\r\n    d.push(`M${a.lines[0][0]} ${a.lines[0][1]}`);\r\n    for (let i = 1, l = a.lines.length; i < l; i++) {\r\n      let p1 = a.lines[i];\r\n      let p2 = a.lines[i + 1];\r\n      if (p2) {\r\n        d.push(`L${p1[0]} ${p1[1]}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n\r\n   if(a.lines.length>2) {\r\n    var p1 = a.lines[0];\r\n    var p2 = a.lines[a.lines.length-1];\r\n\r\n    var p3 = []; //arrow\r\n    var p4 = [];\r\n    var p0 = []; //arrow intersection\r\n\r\n    if (p2) {\r\n      var k = -(p2[0]-p1[0])/(p2[1]-p1[1]);\r\n\r\n      var deltaX = 3;\r\n      p0[0] = p1[0]+0.8*(p2[0]-p1[0]);\r\n      p0[1] = p1[1]+0.8*(p2[1]-p1[1]);\r\n\r\n      p3[0] = p0[0] + deltaX;\r\n      p3[1] = p0[1] + k*deltaX;\r\n\r\n      p4[0] = p0[0] - deltaX;\r\n      p4[1] = p0[1] - k*deltaX;\r\n\r\n      if(Math.abs(p2[1]-p1[1]) < 20) {\r\n\r\n        p3[0] = p0[0] ;\r\n        p3[1] = p0[1] + deltaX*1;\r\n\r\n        p4[0] = p0[0] ;\r\n        p4[1] = p0[1] - deltaX*1;\r\n\r\n      }\r\n\r\n      d.push(`M${p1[0]} ${p1[1]} ${p2[0]} ${p2[1]}`);\r\n       //d.push(`M${p1[0]} ${p1[1]} ${p2[0]} ${p2[1]}`);\r\n      d.push(`M${p2[0]} ${p2[1]} ${p3[0]} ${p3[1]}`);\r\n      d.push(`M${p3[0]} ${p3[1]} ${p4[0]} ${p4[1]}`);\r\n      d.push(`M${p4[0]} ${p4[1]} ${p2[0]} ${p2[1]}`);\r\n     }\r\n    } */\r\n\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(path, {\r\n    d: `${d.join(' ')}`, // `${d.join(' ')}Z`,\r\n    stroke: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#000'),\r\n    strokeWidth: a.width || 1,\r\n    fill: 'none'\r\n  });\r\n\r\n  return path;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderPath.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderPoint.js":
/*!****************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderPoint.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderPoint; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n\r\n\r\nconst SIZE = 25;\r\nconst D = 'M499.968 214.336q-113.832 0 -212.877 38.781t-157.356 104.625 -58.311 142.29q0 62.496 39.897 119.133t112.437 97.929l48.546 27.9 -15.066 53.568q-13.392 50.778 -39.06 95.976 84.816 -35.154 153.45 -95.418l23.994 -21.204 31.806 3.348q38.502 4.464 72.54 4.464 113.832 0 212.877 -38.781t157.356 -104.625 58.311 -142.29 -58.311 -142.29 -157.356 -104.625 -212.877 -38.781z';\r\n\r\n/**\r\n * Create SVGElement from an annotation definition.\r\n * This is used for anntations of type `comment`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGElement} A svg to be rendered\r\n */\r\nfunction renderPoint(a) {\r\n  let outerSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n  let innerSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n  let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n  let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(outerSVG, {\r\n    width: SIZE,\r\n    height: SIZE,\r\n    x: a.x,\r\n    y: a.y\r\n  });\r\n\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(innerSVG, {\r\n    width: SIZE,\r\n    height: SIZE,\r\n    x: 0,\r\n    y: (SIZE * 0.05) * -1,\r\n    viewBox: '0 0 1000 1000'\r\n  });\r\n\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(rect, {\r\n    width: SIZE,\r\n    height: SIZE,\r\n    stroke: '#000',\r\n    fill: '#ff0'\r\n  });\r\n\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(path, {\r\n    d: D,\r\n    strokeWidth: 50,\r\n    stroke: '#000',\r\n    fill: '#fff'\r\n  });\r\n\r\n  innerSVG.appendChild(path);\r\n  outerSVG.appendChild(rect);\r\n  outerSVG.appendChild(innerSVG);\r\n\r\n  return outerSVG;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderPoint.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderRect.js":
/*!***************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderRect.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderRect; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ \"./node_modules/pdf-annotate.js/src/utils/normalizeColor.js\");\n\r\n\r\n\r\n/**\r\n * Create SVGRectElements from an annotation definition.\r\n * This is used for anntations of type `area` and `highlight`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGGElement|SVGRectElement} A group of all rects to be rendered\r\n */\r\nfunction renderRect(a) {\r\n  if (a.type === 'highlight') {\r\n    let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(group, {\r\n      fill: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#ff0'),\r\n      fillOpacity: 0.2\r\n    });\r\n\r\n    a.rectangles.forEach((r) => {\r\n      group.appendChild(createRect(r));\r\n    });\r\n\r\n    return group;\r\n  }\r\n  else {\r\n    let rect = createRect(a);\r\n    Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(rect, {\r\n      stroke: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#f00'),\r\n      fill: 'none'\r\n    });\r\n\r\n    return rect;\r\n  }\r\n}\r\n\r\nfunction createRect(r) {\r\n  let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(rect, {\r\n    x: r.x,\r\n    y: r.y,\r\n    width: r.width,\r\n    height: r.height\r\n  });\r\n\r\n  return rect;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderRect.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/render/renderText.js":
/*!***************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/render/renderText.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return renderText; });\n/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ \"./node_modules/pdf-annotate.js/src/utils/setAttributes.js\");\n/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ \"./node_modules/pdf-annotate.js/src/utils/normalizeColor.js\");\n\r\n\r\n\r\n/**\r\n * Create SVGTextElement from an annotation definition.\r\n * This is used for anntations of type `textbox`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGTextElement} A text to be rendered\r\n */\r\nfunction renderText(a) {\r\n  // Text should be rendered at 0 degrees relative to\r\n  // document rotation\r\n  let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n  Object(_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(text, {\r\n    x: a.x,\r\n    y: a.y,\r\n    fill: Object(_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.color || '#000'),\r\n    fontSize: a.size,\r\n    transform: `rotate(${a.rotation})`,\r\n    style: 'white-space: pre'\r\n  });\r\n  text.innerHTML = a.content;\r\n\r\n  let g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n  g.appendChild(text);\r\n\r\n  return g;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/render/renderText.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/utils/abstractFunction.js":
/*!********************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/utils/abstractFunction.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return abstractFunction; });\n/**\r\n * Throw an Error for an abstract function that hasn't been implemented.\r\n *\r\n * @param {String} name The name of the abstract function\r\n */\r\nfunction abstractFunction(name) {\r\n  throw new Error(name + ' is not implemented');\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/utils/abstractFunction.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/utils/mathUtils.js":
/*!*************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/utils/mathUtils.js ***!
  \*************************************************************/
/*! exports provided: applyTransform, applyInverseTransform, transform, translate, rotate, scale, makePoint, makeVector, makeVectorFromPoints, addVector, multiplyVector, magnitude, negateVector, unitVector, crossProduct */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyTransform\", function() { return applyTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyInverseTransform\", function() { return applyInverseTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transform\", function() { return transform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makePoint\", function() { return makePoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeVector\", function() { return makeVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeVectorFromPoints\", function() { return makeVectorFromPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addVector\", function() { return addVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyVector\", function() { return multiplyVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"magnitude\", function() { return magnitude; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negateVector\", function() { return negateVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unitVector\", function() { return unitVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"crossProduct\", function() { return crossProduct; });\n// Transform point by matrix\r\n//\r\nfunction applyTransform(p, m) {\r\n  return [\r\n    p[0] * m[0] + p[1] * m[2] + m[4],\r\n    p[0] * m[1] + p[1] * m[3] + m[5]\r\n  ];\r\n};\r\n\r\n// Transform point by matrix inverse\r\n//\r\nfunction applyInverseTransform(p, m) {\r\n  let d = m[0] * m[3] - m[1] * m[2];\r\n  return [\r\n    (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d,\r\n    (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d\r\n  ];\r\n};\r\n\r\n// Concatenates two transformation matrices together and returns the result.\r\nfunction transform(m1, m2) {\r\n  return [\r\n    m1[0] * m2[0] + m1[2] * m2[1],\r\n    m1[1] * m2[0] + m1[3] * m2[1],\r\n    m1[0] * m2[2] + m1[2] * m2[3],\r\n    m1[1] * m2[2] + m1[3] * m2[3],\r\n    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\r\n    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\r\n  ];\r\n};\r\n\r\nfunction translate(m, x, y) {\r\n  return [\r\n    m[0],\r\n    m[1],\r\n    m[2],\r\n    m[3],\r\n    m[0] * x + m[2] * y + m[4],\r\n    m[1] * x + m[3] * y + m[5]\r\n  ];\r\n};\r\n\r\nfunction rotate(m, angle) {\r\n  angle = angle * Math.PI / 180;\r\n\r\n  let cosValue = Math.cos(angle);\r\n  let sinValue = Math.sin(angle);\r\n\r\n  return [\r\n    m[0] * cosValue + m[2] * sinValue,\r\n    m[1] * cosValue + m[3] * sinValue,\r\n    m[0] * (-sinValue) + m[2] * cosValue,\r\n    m[1] * (-sinValue) + m[3] * cosValue,\r\n    m[4],\r\n    m[5]\r\n  ];\r\n};\r\n\r\nfunction scale(m, x, y) {\r\n  return [\r\n    m[0] * x,\r\n    m[1] * x,\r\n    m[2] * y,\r\n    m[3] * y,\r\n    m[4],\r\n    m[5]\r\n  ];\r\n};\r\n\r\nfunction makePoint(x, y, z) {\r\n  return { x: x, y: y, z: z };\r\n};\r\n\r\nfunction makeVector(xcoord, ycoord, zcoord) {\r\n  return { xcoord: xcoord, ycoord: ycoord, zcoord: zcoord };\r\n};\r\n\r\nfunction makeVectorFromPoints(pt1, pt2) {\r\n  let xcoord = pt2.x - pt1.x;\r\n  let ycoord = pt2.y - pt1.y;\r\n  let zcoord = pt2.z - pt1.z;\r\n  return makeVector(xcoord, ycoord, zcoord);\r\n};\r\n\r\nfunction addVector(pt, v) {\r\n  return makePoint(pt.x + v.xcoord, pt.y + v.ycoord, pt.z + v.zcoord);\r\n};\r\n\r\nfunction multiplyVector(v, scalar) {\r\n  return makeVector(v.xcoord * scalar, v.ycoord * scalar, v.zcoord * scalar);\r\n};\r\n\r\nfunction magnitude(v) {\r\n  return Math.sqrt(\r\n    Math.pow(v.xcoord, 2) + Math.pow(v.ycoord, 2) + Math.pow(v.zcoord, 2)\r\n  );\r\n};\r\n\r\nfunction negateVector(v) {\r\n  return multiplyVector(v, -1);\r\n};\r\n\r\nfunction unitVector(v) {\r\n  let mag = magnitude(v);\r\n  let xcoord = v.xcoord / mag;\r\n  let ycoord = v.ycoord / mag;\r\n  let zcoord = v.zcoord / mag;\r\n  return makeVector(xcoord, ycoord, zcoord);\r\n};\r\n\r\nfunction crossProduct(u, v) {\r\n  //\r\n  // u X v = < u2*v3 - u3*v2,\r\n  //           u3*v1 - u1*v3,\r\n  //           u1*v2 - u2*v1 >\r\n  let xcoord = u.ycoord * v.zcoord - u.zcoord * v.ycoord;\r\n  let ycoord = u.zcoord * v.xcoord - u.xcoord * v.zcoord;\r\n  let zcoord = u.xcoord * v.ycoord - u.ycoord * v.xcoord;\r\n  return makeVector(xcoord, ycoord, zcoord);\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/utils/mathUtils.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/utils/normalizeColor.js":
/*!******************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/utils/normalizeColor.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeColor; });\nconst REGEX_HASHLESS_HEX = /^([a-f0-9]{6}|[a-f0-9]{3})$/i;\r\n\r\n/**\r\n * Normalize a color value\r\n *\r\n * @param {String} color The color to normalize\r\n * @return {String}\r\n */\r\nfunction normalizeColor(color) {\r\n  if (REGEX_HASHLESS_HEX.test(color)) {\r\n    color = `#${color}`;\r\n  }\r\n  return color;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/utils/normalizeColor.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/utils/setAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/utils/setAttributes.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setAttributes; });\nconst UPPER_REGEX = /[A-Z]/g;\r\n\r\n// Don't convert these attributes from camelCase to hyphenated-attributes\r\nconst BLACKLIST = [\r\n  'viewBox'\r\n];\r\n\r\nlet keyCase = (key) => {\r\n  if (BLACKLIST.indexOf(key) === -1) {\r\n    key = key.replace(UPPER_REGEX, match => '-' + match.toLowerCase());\r\n  }\r\n  return key;\r\n};\r\n\r\n/**\r\n * Set attributes for a node from a map\r\n *\r\n * @param {Node} node The node to set attributes on\r\n * @param {Object} attributes The map of key/value pairs to use for attributes\r\n */\r\nfunction setAttributes(node, attributes) {\r\n  Object.keys(attributes).forEach((key) => {\r\n    node.setAttribute(keyCase(key), attributes[key]);\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/utils/setAttributes.js?");

/***/ }),

/***/ "./node_modules/pdf-annotate.js/src/utils/uuid.js":
/*!********************************************************!*\
  !*** ./node_modules/pdf-annotate.js/src/utils/uuid.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return uuid; });\nconst REGEXP = /[xy]/g;\r\nconst PATTERN = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\r\n\r\nfunction replacement(c) {\r\n  let r = Math.random() * 16 | 0;\r\n  let v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n  return v.toString(16);\r\n}\r\n\r\n/**\r\n * Generate a univierally unique identifier\r\n *\r\n * @return {String} A UUID\r\n */\r\nfunction uuid() {\r\n  return PATTERN.replace(REGEXP, replacement);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/pdf-annotate.js/src/utils/uuid.js?");

/***/ }),

/***/ "./shared/initColorPicker.js":
/*!***********************************!*\
  !*** ./shared/initColorPicker.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return initColorPicker; });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Color picker component\nvar COLORS = [{\n  hex: '#000000',\n  name: 'Black'\n}, {\n  hex: '#EF4437',\n  name: 'Red'\n}, {\n  hex: '#E71F63',\n  name: 'Pink'\n}, {\n  hex: '#8F3E97',\n  name: 'Purple'\n}, {\n  hex: '#65499D',\n  name: 'Deep Purple'\n}, {\n  hex: '#4554A4',\n  name: 'Indigo'\n}, {\n  hex: '#2083C5',\n  name: 'Blue'\n}, {\n  hex: '#35A4DC',\n  name: 'Light Blue'\n}, {\n  hex: '#09BCD3',\n  name: 'Cyan'\n}, {\n  hex: '#009688',\n  name: 'Teal'\n}, {\n  hex: '#43A047',\n  name: 'Green'\n}, {\n  hex: '#8BC34A',\n  name: 'Light Green'\n}, {\n  hex: '#FDC010',\n  name: 'Yellow'\n}, {\n  hex: '#F8971C',\n  name: 'Orange'\n}, {\n  hex: '#F0592B',\n  name: 'Deep Orange'\n}, {\n  hex: '#F06291',\n  name: 'Light Pink'\n}];\nfunction initColorPicker(el, value, onChange) {\n  function getNameFromHex(hex) {\n    var _iterator = _createForOfIteratorHelper(COLORS),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var color = _step.value;\n\n        if (color.hex === hex) {\n          return color.name;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  function setColor(hex, name) {\n    var fireOnChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    a.setAttribute('data-color', hex);\n    a.setAttribute('data-name', name);\n    a.setAttribute('title', name);\n    a.style.background = hex;\n\n    if (fireOnChange && typeof onChange === 'function') {\n      onChange(hex);\n    }\n\n    closePicker();\n  }\n\n  function togglePicker() {\n    if (isPickerOpen) {\n      closePicker();\n    } else {\n      openPicker();\n    }\n  }\n\n  function closePicker() {\n    document.removeEventListener('keyup', handleDocumentKeyup);\n\n    if (picker && picker.parentNode) {\n      picker.parentNode.removeChild(picker);\n    }\n\n    isPickerOpen = false;\n    a.focus();\n  }\n\n  function openPicker() {\n    if (!picker) {\n      picker = document.createElement('div');\n      picker.style.background = '#fff';\n      picker.style.border = '1px solid #ccc';\n      picker.style.padding = '2px';\n      picker.style.position = 'absolute';\n      picker.style.width = '122px';\n      el.style.position = 'relative';\n      COLORS.map(createColorOption).forEach(function (c) {\n        c.style.margin = '2px';\n\n        c.onclick = function () {\n          setColor(c.getAttribute('data-color'), c.getAttribute('data-name'));\n        };\n\n        picker.appendChild(c);\n      });\n    }\n\n    document.addEventListener('keyup', handleDocumentKeyup);\n    el.appendChild(picker);\n    isPickerOpen = true;\n  }\n\n  function createColorOption(color) {\n    var e = document.createElement('a');\n    e.className = 'color';\n    e.setAttribute('href', 'javascript://');\n    e.setAttribute('title', color.name);\n    e.setAttribute('data-name', color.name);\n    e.setAttribute('data-color', color.hex);\n    e.style.background = color.hex;\n    return e;\n  }\n\n  function handleDocumentKeyup(e) {\n    if (e.keyCode === 27) {\n      closePicker();\n    }\n  }\n\n  var picker;\n  var isPickerOpen = false;\n  var name = getNameFromHex(value);\n  var a = createColorOption({\n    hex: value,\n    name: name\n  });\n  a.onclick = togglePicker;\n  el.appendChild(a);\n  setColor(value, name, false);\n}\n\n//# sourceURL=webpack:///./shared/initColorPicker.js?");

/***/ }),

/***/ "./web/index.js":
/*!**********************!*\
  !*** ./web/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_pdf_annotate_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/pdf-annotate.js/ */ \"./node_modules/pdf-annotate.js/index.js\");\n/* harmony import */ var _shared_initColorPicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/initColorPicker */ \"./shared/initColorPicker.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nfunction htmlEscape(text) {\n  return text.replace('&', '&amp;').replace('>', '&gt;').replace('<', '&lt;').replace('\"', '&quot;').replace(\"'\", '&#39;');\n}\n\nvar UI = _node_modules_pdf_annotate_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"].UI;\nvar documentId = 'example.pdf';\nvar PAGE_HEIGHT;\nvar RENDER_OPTIONS = {\n  documentId: documentId,\n  pdfDocument: null,\n  scale: parseFloat(localStorage.getItem(\"\".concat(documentId, \"/scale\")), 10) || 1.33,\n  rotate: parseInt(localStorage.getItem(\"\".concat(documentId, \"/rotate\")), 10) || 0\n};\n_node_modules_pdf_annotate_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"].setStoreAdapter(new _node_modules_pdf_annotate_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"].LocalStoreAdapter());\npdfjsLib.workerSrc = './node_modules/pdfjs-dist/build/pdf.worker.js'; // Render stuff\n\nvar NUM_PAGES = 0;\nvar renderedPages = [];\nvar okToRender = false;\ndocument.getElementById('content-wrapper').addEventListener('scroll', function (e) {\n  var visiblePageNum = Math.round(e.target.scrollTop / PAGE_HEIGHT) + 1;\n  var visiblePage = document.querySelector(\".page[data-page-number=\\\"\".concat(visiblePageNum, \"\\\"][data-loaded=\\\"false\\\"]\"));\n\n  if (renderedPages.indexOf(visiblePageNum) === -1) {\n    okToRender = true;\n    renderedPages.push(visiblePageNum);\n  } else {\n    okToRender = false;\n  }\n\n  if (visiblePage && okToRender) {\n    setTimeout(function () {\n      UI.renderPage(visiblePageNum, RENDER_OPTIONS);\n    });\n  }\n});\n\nfunction render() {\n  // pdfjsLib.getDocument(RENDER_OPTIONS.documentId).then((pdf) => {\n  //   RENDER_OPTIONS.pdfDocument = pdf;\n  //   let viewer = document.getElementById('viewer');\n  //   viewer.innerHTML = '';\n  //   NUM_PAGES = pdf.pdfInfo.numPages;\n  //   for (let i=0; i<NUM_PAGES; i++) {\n  //     let page = UI.createPage(i+1);\n  //     viewer.appendChild(page);\n  //   }\n  //   UI.renderPage(1, RENDER_OPTIONS).then(([pdfPage, annotations]) => {\n  //     let viewport = pdfPage.getViewport(RENDER_OPTIONS.scale, RENDER_OPTIONS.rotate);\n  //     PAGE_HEIGHT = viewport.height;\n  //   });\n  // });\n  var loadingTask = pdfjsLib.getDocument({\n    url: RENDER_OPTIONS.documentId,\n    cMapUrl: 'shared/cmaps/',\n    cMapPacked: true\n  });\n  loadingTask.promise.then(function (pdf) {\n    RENDER_OPTIONS.pdfDocument = pdf;\n    var viewer = document.getElementById('viewer');\n    viewer.innerHTML = '';\n    NUM_PAGES = pdf.numPages;\n\n    for (var i = 0; i < NUM_PAGES; i++) {\n      var page = UI.createPage(i + 1);\n      viewer.appendChild(page);\n    }\n\n    UI.renderPage(1, RENDER_OPTIONS).then(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          pdfPage = _ref2[0],\n          annotations = _ref2[1];\n\n      var viewport = pdfPage.getViewport({\n        scale: RENDER_OPTIONS.scale,\n        rotation: RENDER_OPTIONS.rotate\n      });\n      PAGE_HEIGHT = viewport.height;\n    });\n  });\n}\n\nrender(); // Text stuff\n\n(function () {\n  var textSize;\n  var textColor;\n\n  function initText() {\n    var size = document.querySelector('.toolbar .text-size');\n    [8, 9, 10, 11, 12, 14, 18, 24, 30, 36, 48, 60, 72, 96].forEach(function (s) {\n      size.appendChild(new Option(s, s));\n    });\n    setText(localStorage.getItem(\"\".concat(RENDER_OPTIONS.documentId, \"/text/size\")) || 10, localStorage.getItem(\"\".concat(RENDER_OPTIONS.documentId, \"/text/color\")) || '#000000');\n    Object(_shared_initColorPicker__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(document.querySelector('.text-color'), textColor, function (value) {\n      setText(textSize, value);\n    });\n  }\n\n  function setText(size, color) {\n    var modified = false;\n\n    if (textSize !== size) {\n      modified = true;\n      textSize = size;\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/text/size\"), textSize);\n      document.querySelector('.toolbar .text-size').value = textSize;\n    }\n\n    if (textColor !== color) {\n      modified = true;\n      textColor = color;\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/text/color\"), textColor);\n      var selected = document.querySelector('.toolbar .text-color.color-selected');\n\n      if (selected) {\n        selected.classList.remove('color-selected');\n        selected.removeAttribute('aria-selected');\n      }\n\n      selected = document.querySelector(\".toolbar .text-color[data-color=\\\"\".concat(color, \"\\\"]\"));\n\n      if (selected) {\n        selected.classList.add('color-selected');\n        selected.setAttribute('aria-selected', true);\n      }\n    }\n\n    if (modified) {\n      UI.setText(textSize, textColor);\n    }\n  }\n\n  function handleTextSizeChange(e) {\n    setText(e.target.value, textColor);\n  }\n\n  document.querySelector('.toolbar .text-size').addEventListener('change', handleTextSizeChange);\n  initText();\n})(); // Pen stuff\n\n\n(function () {\n  var penSize;\n  var penColor;\n\n  function initPen() {\n    var size = document.querySelector('.toolbar .pen-size');\n\n    for (var i = 0; i < 20; i++) {\n      size.appendChild(new Option(i + 1, i + 1));\n    }\n\n    setPen(localStorage.getItem(\"\".concat(RENDER_OPTIONS.documentId, \"/pen/size\")) || 1, localStorage.getItem(\"\".concat(RENDER_OPTIONS.documentId, \"/pen/color\")) || '#000000');\n    Object(_shared_initColorPicker__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(document.querySelector('.pen-color'), penColor, function (value) {\n      setPen(penSize, value);\n    });\n  }\n\n  function setPen(size, color) {\n    var modified = false;\n\n    if (penSize !== size) {\n      modified = true;\n      penSize = size;\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/pen/size\"), penSize);\n      document.querySelector('.toolbar .pen-size').value = penSize;\n    }\n\n    if (penColor !== color) {\n      modified = true;\n      penColor = color;\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/pen/color\"), penColor);\n      var selected = document.querySelector('.toolbar .pen-color.color-selected');\n\n      if (selected) {\n        selected.classList.remove('color-selected');\n        selected.removeAttribute('aria-selected');\n      }\n\n      selected = document.querySelector(\".toolbar .pen-color[data-color=\\\"\".concat(color, \"\\\"]\"));\n\n      if (selected) {\n        selected.classList.add('color-selected');\n        selected.setAttribute('aria-selected', true);\n      }\n    }\n\n    if (modified) {\n      UI.setPen(penSize, penColor);\n    }\n  }\n\n  function handlePenSizeChange(e) {\n    setPen(e.target.value, penColor);\n  }\n\n  document.querySelector('.toolbar .pen-size').addEventListener('change', handlePenSizeChange);\n  initPen();\n})(); // Toolbar buttons\n\n\n(function () {\n  var tooltype = localStorage.getItem(\"\".concat(RENDER_OPTIONS.documentId, \"/tooltype\")) || 'cursor';\n\n  if (tooltype) {\n    setActiveToolbarItem(tooltype, document.querySelector(\".toolbar button[data-tooltype=\".concat(tooltype, \"]\")));\n  }\n\n  function setActiveToolbarItem(type, button) {\n    var active = document.querySelector('.toolbar button.active');\n\n    if (active) {\n      active.classList.remove('active');\n\n      switch (tooltype) {\n        case 'cursor':\n          UI.disableEdit();\n          break;\n\n        case 'eraser':\n          UI.disableEraser();\n          break;\n\n        case 'draw':\n          UI.disablePen();\n          break;\n\n        case 'text':\n          UI.disableText();\n          break;\n\n        case 'point':\n          UI.disablePoint();\n          break;\n\n        case 'area':\n        case 'highlight':\n        case 'strikeout':\n          UI.disableRect();\n          break;\n      }\n    }\n\n    if (button) {\n      button.classList.add('active');\n    }\n\n    if (tooltype !== type) {\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/tooltype\"), type);\n    }\n\n    tooltype = type;\n\n    switch (type) {\n      case 'cursor':\n        UI.enableEdit();\n        break;\n\n      case 'eraser':\n        UI.enableEraser();\n        break;\n\n      case 'draw':\n        UI.enablePen();\n        break;\n\n      case 'text':\n        UI.enableText();\n        break;\n\n      case 'point':\n        UI.enablePoint();\n        break;\n\n      case 'area':\n      case 'highlight':\n      case 'strikeout':\n        UI.enableRect(type);\n        break;\n    }\n  }\n\n  function handleToolbarClick(e) {\n    if (e.target.nodeName === 'BUTTON') {\n      setActiveToolbarItem(e.target.getAttribute('data-tooltype'), e.target);\n    }\n  }\n\n  document.querySelector('.toolbar').addEventListener('click', handleToolbarClick);\n})(); // Scale/rotate\n\n\n(function () {\n  function setScaleRotate(scale, rotate) {\n    scale = parseFloat(scale, 10);\n    rotate = parseInt(rotate, 10);\n\n    if (RENDER_OPTIONS.scale !== scale || RENDER_OPTIONS.rotate !== rotate) {\n      RENDER_OPTIONS.scale = scale;\n      RENDER_OPTIONS.rotate = rotate;\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/scale\"), RENDER_OPTIONS.scale);\n      localStorage.setItem(\"\".concat(RENDER_OPTIONS.documentId, \"/rotate\"), RENDER_OPTIONS.rotate % 360);\n      render();\n    }\n  }\n\n  function handleScaleChange(e) {\n    setScaleRotate(e.target.value, RENDER_OPTIONS.rotate);\n  }\n\n  function handleRotateCWClick() {\n    setScaleRotate(RENDER_OPTIONS.scale, RENDER_OPTIONS.rotate + 90);\n  }\n\n  function handleRotateCCWClick() {\n    setScaleRotate(RENDER_OPTIONS.scale, RENDER_OPTIONS.rotate - 90);\n  }\n\n  document.querySelector('.toolbar select.scale').value = RENDER_OPTIONS.scale;\n  document.querySelector('.toolbar select.scale').addEventListener('change', handleScaleChange);\n  document.querySelector('.toolbar .rotate-ccw').addEventListener('click', handleRotateCCWClick);\n  document.querySelector('.toolbar .rotate-cw').addEventListener('click', handleRotateCWClick);\n})(); // Clear toolbar button\n\n\n(function () {\n  function handleClearClick(e) {\n    if (confirm('Are you sure you want to clear annotations?')) {\n      for (var i = 0; i < NUM_PAGES; i++) {\n        document.querySelector(\"div#pageContainer\".concat(i + 1, \" svg.annotationLayer\")).innerHTML = '';\n      }\n\n      localStorage.removeItem(\"\".concat(RENDER_OPTIONS.documentId, \"/annotations\"));\n    }\n  }\n\n  document.querySelector('a.clear').addEventListener('click', handleClearClick);\n})(); // Comment stuff\n\n\n(function (window, document) {\n  var commentList = document.querySelector('#comment-wrapper .comment-list-container');\n  var commentForm = document.querySelector('#comment-wrapper .comment-list-form');\n  var commentText = commentForm.querySelector('input[type=\"text\"]');\n\n  function supportsComments(target) {\n    var type = target.getAttribute('data-pdf-annotate-type');\n    return ['point', 'highlight', 'area'].indexOf(type) > -1;\n  }\n\n  function insertComment(comment) {\n    var child = document.createElement('div');\n    child.className = 'comment-list-item';\n    child.innerHTML = htmlEscape(comment.content);\n    commentList.appendChild(child);\n  }\n\n  function handleAnnotationClick(target) {\n    if (supportsComments(target)) {\n      var _documentId = target.parentNode.getAttribute('data-pdf-annotate-document');\n\n      var annotationId = target.getAttribute('data-pdf-annotate-id');\n      _node_modules_pdf_annotate_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().getComments(_documentId, annotationId).then(function (comments) {\n        commentList.innerHTML = '';\n        commentForm.style.display = '';\n        commentText.focus();\n\n        commentForm.onsubmit = function () {\n          _node_modules_pdf_annotate_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStoreAdapter().addComment(_documentId, annotationId, commentText.value.trim()).then(insertComment).then(function () {\n            commentText.value = '';\n            commentText.focus();\n          });\n          return false;\n        };\n\n        comments.forEach(insertComment);\n      });\n    }\n  }\n\n  function handleAnnotationBlur(target) {\n    if (supportsComments(target)) {\n      commentList.innerHTML = '';\n      commentForm.style.display = 'none';\n      commentForm.onsubmit = null;\n      insertComment({\n        content: 'No comments'\n      });\n    }\n  }\n\n  UI.addEventListener('annotation:click', handleAnnotationClick);\n  UI.addEventListener('annotation:blur', handleAnnotationBlur);\n})(window, document);\n\n//# sourceURL=webpack:///./web/index.js?");

/***/ })

/******/ });